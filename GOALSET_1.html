<!--
    Note: This file has been refactored to be compliant with the main application's custom exercise guide.
    All CSS classes, element IDs, and localStorage keys have been prefixed with "custom-formula-" to avoid conflicts.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formula Goal Tracker</title>
    <script>
      // Configure MathJax before it loads
      window.MathJax = {
        options: {
          enableMenu: false
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global',
          displayAlign: 'center'
        },
        chtml: {
          matchFontHeight: true
        },
        startup: {
          ready: () => {
            console.log('MathJax is configured and ready.');
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #f5a623;
            --background-color: #f7f9fc;
            --text-color: #333;
            --card-bg-color: #ffffff;
            --border-color: #e0e0e0;
            --success-color: #7ed321;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --sidebar-width: 280px;
        }

        .custom-formula-dark-mode {
            --primary-color: #58a6ff;
            --secondary-color: #f5a623;
            --background-color: #0d1117;
            --text-color: #c9d1d9;
            --card-bg-color: #161b22;
            --border-color: #30363d;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 5rem 2rem 2rem 2rem;
            display: flex;
            justify-content: center;
            transition: background-color 0.3s, color 0.3s;
        }

        .custom-formula-container {
            width: 100%;
            max-width: 800px;
            transition: transform 0.3s ease-in-out;
        }

        .custom-formula-sidebar-open .custom-formula-container {
            transform: translateX(var(--sidebar-width));
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            color: var(--primary-color);
            font-weight: 600;
        }

        .custom-formula-card {
            background-color: var(--card-bg-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .custom-formula-card.text-center {
            text-align: center;
        }

        .custom-formula-upload-section {
            display: grid;
    grid-template-columns: 1fr;
            gap: 1.5rem;
            align-items: start;
        }

        .custom-formula-upload-box {
            text-align: center;
            border: 2px dashed var(--border-color);
            padding-top: 2rem;
            padding-bottom: 2rem;
            transition: border-color 0.2s, background-color 0.2s;
        }

        .custom-formula-upload-box.custom-formula-drag-over {
            border-color: var(--primary-color);
            background-color: rgba(74, 144, 226, 0.05);
        }
        .custom-formula-dark-mode .custom-formula-upload-box.custom-formula-drag-over {
            background-color: rgba(88, 166, 255, 0.1);
        }

        .custom-formula-upload-box.custom-formula-drag-invalid {
            border-color: var(--secondary-color);
            background-color: rgba(245, 166, 35, 0.05);
        }
        .custom-formula-dark-mode .custom-formula-upload-box.custom-formula-drag-invalid {
            background-color: rgba(245, 166, 35, 0.1);
        }


        .custom-formula-btn {
            background-color: var(--primary-color);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: background-color 0.3s ease;
            display: inline-block;
            text-decoration: none;
        }

        .custom-formula-btn:hover {
            background-color: #357abd;
        }

        .custom-formula-btn span {
            display: inline-block;
            transition: opacity 0.15s ease-in-out;
        }

        .custom-formula-btn.custom-formula-text-fade-out span {
            opacity: 0;
        }

        body.custom-formula-drag-active::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.02);
            z-index: 9998; /* Below sidebar and modals */
            pointer-events: none; /* Allow events to pass through */
        }

        .custom-formula-btn-secondary {
            background-color: var(--secondary-color);
        }
        .custom-formula-btn-secondary:hover {
            background-color: #d99014;
        }

        .custom-formula-btn-float-right {
            float: right;
        }
        .custom-formula-btn-small {
            padding: 0.2rem 0.5rem;
            font-size: 0.8rem;
        }

        .custom-formula-btn-ask-ai {
            background: linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%) !important;
            color: #FFD700 !important;
        }
        .custom-formula-btn-ask-ai:hover {
            opacity: 0.9;
        }

        .custom-formula-ml-1 {
            margin-left: 0.5rem;
        }

        input[type="file"] {
            display: none;
        }

        #ocr-status {
            margin-top: 1rem;
            min-height: 20px;
            font-style: italic;
            color: #666;
        }

        .custom-formula-progress-section {
            margin-bottom: 2rem;
        }

        .custom-formula-progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            height: 20px;
            overflow: hidden;
        }

        .custom-formula-progress-bar {
            width: 0%;
            height: 100%;
            background-color: var(--success-color);
            transition: width 0.4s ease-in-out;
        }

        #custom-formula-progress-text {
            text-align: center;
            margin-top: 0.5rem;
            font-weight: 500;
        }

        #custom-formula-formula-list {
            list-style-type: none;
            padding: 0;
        }

        .custom-formula-formula-item {
            display: flex;
            flex-direction: column;
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 1rem 1.5rem;
            margin-bottom: 1rem;
            transition: box-shadow 0.3s ease;
        }

        .custom-formula-formula-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .custom-formula-formula-item.custom-formula-completed {
        }

        .custom-formula-formula-item.custom-formula-completed .custom-formula-formula-text {
        }

        .custom-formula-formula-item input[type="checkbox"] {
            margin-right: 1.5rem;
            min-width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--primary-color);
        }

        .custom-formula-goal-content {
            display: flex;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .expandable-dot {
            position: absolute;
            left: -15px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background-color: var(--primary-color);
            border-radius: 50%;
            display: none;
        }

        .custom-formula-formula-item.has-subgoals.collapsed .expandable-dot {
            display: block;
        }

        .custom-formula-formula-text {
            flex-grow: 1;
            font-size: 16px;
            overflow-x: auto; /* Allow scrolling for very long formulas */
            max-width: 100%;
            cursor: pointer;
            scrollbar-width: none; /* For Firefox */
        }
        .custom-formula-formula-text::-webkit-scrollbar {
            display: none; /* For Chrome, Safari, and Opera */
        }

        .custom-formula-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 1000;
        }

        .custom-formula-modal-overlay.custom-formula-show {
            opacity: 1;
            visibility: visible;
        }

        .custom-formula-modal-content {
            background-color: var(--card-bg-color);
            color: var(--text-color);
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s ease, background-color 0.3s, color 0.3s;
            width: 90%;
            max-width: 400px;
        }

        .custom-formula-modal-overlay.custom-formula-show .custom-formula-modal-content {
            transform: scale(1);
        }

        .custom-formula-modal-content span {
            font-size: 5rem;
        }

        .custom-formula-modal-content h2 {
            margin-top: 0;
        }

        .custom-formula-modal-actions {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        /* Spinner Styles */
        .custom-formula-spinner {
            display: none;
            width: 40px;
            height: 40px;
            margin: 20px auto;
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            animation: custom-formula-spin 1s linear infinite;
        }

        @keyframes custom-formula-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Hide actions when loading */
        .custom-formula-loading .custom-formula-modal-actions {
            display: none;
        }
        .custom-formula-loading .custom-formula-spinner {
            display: block;
        }

        @keyframes celebration-animation {
            0% { transform: scale(1); }
            50% { transform: scale(1.3) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        #custom-formula-celebration-modal.custom-formula-show .custom-formula-modal-content span {
            animation: celebration-animation 0.8s ease-in-out;
        }

        .custom-formula-timer-box {
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem 2rem;
            display: inline-block;
        }

        .custom-formula-timer-display-btn {
            background: none;
            border: none;
            padding: 0;
            font-size: 3rem;
            cursor: pointer;
            color: inherit;
            font-family: inherit;
            border-radius: 8px; /* For focus outline */
        }

        .custom-formula-timer-display-btn:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        .custom-formula-timer-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        #custom-formula-manual-add-card .custom-formula-form-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        #custom-formula-manual-add-card .custom-formula-form-group textarea {
            width: 80%;
            max-width: 400px;
        }

        #custom-formula-manual-add-card p {
            margin: 0.5rem 0 0 0;
            padding: 0;
        }

        .custom-formula-form-group {
            margin-bottom: 1.5rem;
            text-align: left;
        }

        .custom-formula-form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .custom-formula-form-group input,
        .custom-formula-form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            box-sizing: border-box; /* Add this line to fix overflow */
            border-radius: 5px;
            background-color: var(--background-color);
            color: var(--text-color);
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
        }

        /* --- Sidebar & Sandwich Button --- */
        .custom-formula-sandwich-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            background: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .custom-formula-sandwich-btn .custom-formula-line {
            width: 24px;
            height: 2px;
            background-color: var(--text-color);
            margin: 3px 0;
            transition: transform 0.3s;
        }

        .custom-formula-sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: var(--sidebar-width);
            background-color: var(--card-bg-color);
            border-right: 1px solid var(--border-color);
            transform: translateX(-100%); /* Use percentage to ensure it's fully off-screen */
            transition: transform 0.3s ease-in-out;
            z-index: 999;
            padding: 2rem 1.5rem;
            overflow-y: auto;
            box-sizing: border-box; /* Ensure padding is included in the width */
        }

        .custom-formula-sidebar-open .custom-formula-sidebar {
            transform: translateX(0);
        }

        .custom-formula-sidebar h2 {
            color: var(--primary-color);
            margin-top: 0;
            padding-top: 3rem;
        }

        .custom-formula-sidebar .custom-formula-btn {
            width: 100%;
        }

        #custom-formula-show-uncompleted-btn {
            margin-bottom: 0.5rem;
        }

        #custom-formula-show-failed-btn {
            margin-bottom: 1rem;
        }

        /* --- Dark Mode Toggle --- */
        .custom-formula-dark-mode-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 2rem;
        }

        .custom-formula-dark-mode-toggle label {
            font-weight: 500;
        }

        .custom-formula-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .custom-formula-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .custom-formula-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 28px;
        }

        .custom-formula-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .custom-formula-slider {
            background-color: var(--primary-color);
        }

        input:checked + .custom-formula-slider:before {
            transform: translateX(22px);
        }

        #saved-categories-list {
            list-style: none;
            padding: 0;
        }

        #custom-formula-saved-data-view .custom-formula-formula-item,
        #custom-formula-uncompleted-data-view .custom-formula-formula-item,
        #custom-formula-failed-data-view .custom-formula-formula-item {
            padding-left: 0.5rem;
            padding-right: 0.5rem;
        }

        .custom-formula-sidebar-button {
            background: none;
            border: none;
            padding: 0.5rem 0.5rem;
            font: inherit;
            color: var(--primary-color);
            text-align: left;
            cursor: pointer;
            width: 100%;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .custom-formula-sidebar-button:hover,
        .custom-formula-sidebar-button:focus-visible {
            background-color: rgba(0, 0, 0, 0.05);
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        .custom-formula-btn:focus-visible {
            box-shadow: 0 0 0 2px var(--card-bg-color), 0 0 0 4px var(--primary-color);
        }

        .custom-formula-sandwich-btn:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        .custom-formula-switch input:focus-visible + .custom-formula-slider {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        .custom-formula-dark-mode .custom-formula-sidebar-button:hover,
        .custom-formula-dark-mode .custom-formula-sidebar-button:focus-visible {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .custom-formula-subgoal-list {
            list-style: none;
            padding: 1rem 0 0 0;
            margin: 1rem 0 0 0;
            border-top: 1px solid var(--border-color);
            width: 100%;
            padding-top: 1rem;
        }

        .custom-formula-subgoal-item {
            padding: 1rem 0 1rem 0 !important; /* Align with parent text */
            border: none !important;
            margin: 0 !important;
            box-shadow: none !important;
            background: transparent !important;
            flex-direction: row !important; /* Subgoal items are rows */
            align-items: center !important;
        }

        #custom-formula-formula-list .custom-formula-formula-item input[type="checkbox"] {
            touch-action: pan-y;
        }

        .custom-formula-subgoal-item {
            touch-action: pan-y;
            cursor: grab;
            border-bottom: 1px dotted var(--border-color) !important;
        }

        .custom-formula-dragging {
            opacity: 0.9;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2) !important;
            background-color: var(--card-bg-color) !important;
            cursor: grabbing;
        }

        .custom-formula-drag-placeholder {
            background-color: rgba(0,0,0,0.05) !important;
            border: 2px dashed var(--border-color) !important;
            box-shadow: none !important;
        }

        .custom-formula-formula-item.with-border {
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }

        /* Saved Data View */
        .custom-formula-view-header {
            text-align: center;
            margin-top: 1rem;
        }
        .custom-formula-subcategory-item summary {
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: 600;
            padding: 1rem;
            background-color: rgba(0,0,0,0.05);
            border-radius: 5px;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .custom-formula-dark-mode .custom-formula-subcategory-item summary {
             background-color: rgba(255,255,255,0.05);
        }

        .custom-formula-view-actions {
            display: flex;
            gap: 0.5rem;
        }

        .custom-formula-category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 1rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        #custom-formula-formula-list-header {
            display: none;
            text-align: center;
            margin-bottom: 1rem;
        }

        #custom-formula-session-category-heading {
            margin: 0;
            color: var(--primary-color);
        }

        #custom-formula-session-subcategory-heading {
            margin: 0;
            font-weight: 400;
        }

        .custom-formula-subcategory-item ul {
            list-style: none;
            padding: 0;
        }

        #custom-formula-clear-formula-list {
            list-style-type: none;
            padding: 0;
            text-align: left;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        ul#custom-formula-clear-formula-list li.custom-formula-formula-item {
            padding: 0.5rem;
            border: none;
            background-color: transparent;
            border-radius: 0;
            margin-bottom: 0;
            box-shadow: none;
            transition: none;
            flex-direction: column;
            align-items: flex-start;
        }

        ul#custom-formula-clear-formula-list li.custom-formula-formula-item.with-border > .custom-formula-goal-content {
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;

        }

        ul#custom-formula-clear-formula-list .custom-formula-formula-item .custom-formula-goal-content {
            display: flex;
            align-items: center;
        }

        #custom-formula-clear-formula-list .custom-formula-formula-item:hover {
            box-shadow: none;
        }

        #custom-formula-clear-formula-list .custom-formula-formula-item:last-child {
            border-bottom: none;
        }

        #custom-formula-clear-formula-list .custom-formula-formula-item input[type="checkbox"] {
            margin-right: 1rem;
        }

        #custom-formula-clear-formula-list .custom-formula-subgoal-item {
            padding-left: 2rem !important;
        }

        #custom-formula-ocr-progress-modal .custom-formula-progress-bar-container {
            height: 24px;
            background-color: #e9ecef;
        }

        #custom-formula-ocr-progress-bar {
            background-color: var(--primary-color);
        }

        .d-none {
            display: none;
        }

        .timer{display:flex;gap:12px;align-items:center;justify-content:center;}
        .reel{
            position: relative;
            width:72px;height:calc(40px * 3);
            overflow:hidden;border-radius:10px;
            background: var(--background-color);
            border: 1px solid var(--border-color);
            touch-action:none;
            -webkit-user-select:none;-ms-user-select:none;user-select:none;display:block;
        }
        .reel-inner{display:flex;flex-direction:column;align-items:center;will-change:transform}
        .reel span{display:block;height:40px;line-height:40px;width:100%;text-align:center;font-size:1.3rem;opacity:0.45;transform:scale(0.9);transition:transform 140ms,opacity 140ms,color 0.3s;color: var(--text-color);}
        .reel span.active{opacity:1;transform:scale(1);font-size:1.5rem}
        .timer .colon{font-size:2rem;}
        .reel::after{content:"";position:absolute;left:0;right:0;top:50%;height:40px;margin-top:calc(40px / -2);border-top:1.5px solid var(--border-color);border-bottom:1.5px solid var(--border-color);pointer-events:none; transition: border-color 0.3s;}

        @media (max-width: 600px) {
            body {
                padding: 5rem 1rem 1rem 1rem;
            }
            .custom-formula-upload-section {
                grid-template-columns: 1fr;
            }
            .custom-formula-card {
                padding: 1.5rem;
            }
        }

        /* Add these styles to ensure proper MathJax display behavior */
        .math-center, .math-left {
            display: block;
            width: 100%;
            margin: 1em 0;
            overflow-x: auto;
            scrollbar-width: none; /* For Firefox */
        }

        .math-center::-webkit-scrollbar,
        .math-left::-webkit-scrollbar {
            display: none; /* For Chrome, Safari, and Opera */
        }

        .math-center {
            text-align: center;
        }

        .math-left {
            text-align: left;
        }

        /* Ensure MathJax containers respect the alignment */
        .math-center mjx-container,
        .math-left mjx-container {
            display: block !important;
            text-align: inherit !important;
            margin: 0 auto !important;
        }

        .math-center mjx-container {
            text-align: center !important;
        }

        .math-left mjx-container {
            text-align: left !important;
            margin: 0 !important;
        }

        .custom-formula-shortcuts {
            display: flex;
            overflow-x: auto;
            white-space: nowrap;
            gap: 0.5rem;
            padding: 0.5rem 0;
            margin-bottom: 1rem;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) var(--background-color);
        }

        .custom-formula-shortcut-btn {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 0.5rem 0.75rem;
            border-radius: 15px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            flex-shrink: 0;
            height: 38px; /* Set a fixed height for all buttons */
            box-sizing: border-box; /* Ensure padding is included in the height */
        }

        .custom-formula-shortcut-btn:hover {
            background-color: rgba(74, 144, 226, 0.1);
            border-color: var(--primary-color);
        }

        .custom-formula-shortcut-btn:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* Print Styles */
        @media print {
            body.custom-formula-printing > *:not(.custom-formula-export-container) {
                display: none !important;
            }

            body.custom-formula-printing .custom-formula-export-container {
                display: block !important;
                position: static !important;
                left: auto !important;
                top: auto !important;
                width: 100% !important;
                background: white !important;
                color: black !important;
            }

            body.custom-formula-printing {
                background: white !important;
                padding: 0 !important;
                margin: 0 !important;
            }

            @page {
                margin: 2cm;
            }
        }

        /* Enhanced export styles */
        .custom-formula-export-container mjx-container {
            display: inline-block !important;
            line-height: 1.2 !important;
        }

        .custom-formula-export-container .math-center,
        .custom-formula-export-container .math-left {
            margin: 1em 0;
            padding: 0.5em 0;
        }

        .custom-formula-export-container .export-goal-content,
        .custom-formula-export-container .export-subgoal-content {
            line-height: 1.4;
        }

        /* Ensure SVG rendering for MathJax in exports */
        .custom-formula-export-container mjx-container svg {
            display: inline;
            max-width: 100%;
        }

        @media print {
            .custom-formula-export-container {
                width: 100% !important;
                max-width: none !important;
                padding: 20mm !important;
                margin: 0 !important;
                background: white !important;
                color: black !important;
                font-size: 12pt !important;
            }

            .custom-formula-export-container h1 {
                font-size: 18pt !important;
                color: #4a90e2 !important;
            }

            .custom-formula-export-container h2 {
                font-size: 14pt !important;
                color: #666666 !important;
            }

            mjx-container {
                font-size: 110% !important;
            }
        }
    </style>
</head>
<body>
    <button class="custom-formula-sandwich-btn" id="custom-formula-sandwich-btn" aria-label="Open menu" aria-expanded="false">
        <div class="custom-formula-line"></div>
        <div class="custom-formula-line"></div>
        <div class="custom-formula-line"></div>
    </button>

    <div class="custom-formula-sidebar" id="custom-formula-sidebar">
        <h2>Menu</h2>
        <div class="custom-formula-dark-mode-toggle">
            <label for="custom-formula-dark-mode-switch">Dark Mode</label>
            <label class="custom-formula-switch">
                <input type="checkbox" id="custom-formula-dark-mode-switch">
                <span class="custom-formula-slider"></span>
            </label>
        </div>
        <hr>
        <button id="custom-formula-show-uncompleted-btn" class="custom-formula-btn">Uncompleted Sessions</button>
        <button id="custom-formula-show-failed-btn" class="custom-formula-btn custom-formula-btn-secondary">Failed Sessions</button>
        <hr>
        <button id="custom-formula-export-btn" class="custom-formula-btn" style="margin-bottom: 0.5rem;">Export All Data</button>
        <button id="custom-formula-import-btn" class="custom-formula-btn custom-formula-btn-secondary">Import All Data</button>
        <input type="file" id="custom-formula-import-file-input" accept=".json" style="display: none;">
        <hr>
        <h3>Saved Categories</h3>
        <ul id="custom-formula-saved-categories-list">
            <!-- Categories will be populated here -->
        </ul>
    </div>

    <div class="custom-formula-container" id="custom-formula-main-container">
        <header>
            <h1>Formula Goal Tracker</h1>
            <p>Upload an image or JSON file to track your goals.</p>
        </header>


        <div class="custom-formula-card custom-formula-upload-section">
            <div class="custom-formula-upload-box">
                <h2>1. Upload an Image</h2>
                <p>Extract formulas from an image using OCR.</p>
                <label for="custom-formula-image-upload" class="custom-formula-btn"><span>Upload Image</span></label>
                <input type="file" id="custom-formula-image-upload" accept="image/*">
            </div>
            <div class="custom-formula-upload-box">
                <h2>2. Upload a JSON file</h2>
                <p>Or load formulas from a JSON array.</p>
                <label for="custom-formula-json-upload" class="custom-formula-btn"><span>Upload JSON</span></label>
                <input type="file" id="custom-formula-json-upload" accept=".json">
                <br><br>
                <a href="#" id="custom-formula-download-example" class="custom-formula-btn custom-formula-btn-secondary">Download Example JSON</a>
            </div>
        </div>

        <div class="custom-formula-card text-center" id="custom-formula-manual-add-card">
            <h2>3. Add Goals Manually</h2>
            <div class="custom-formula-shortcuts">
                <button class="custom-formula-shortcut-btn" data-code="\">\</button>
                <button class="custom-formula-shortcut-btn" data-code="\[|\]">&lbrack;\]</button>
                <button class="custom-formula-shortcut-btn" data-code="\text{|}">\text{}</button>
                <button class="custom-formula-shortcut-btn" data-code="~">~</button>
                <button class="custom-formula-shortcut-btn" data-code="$$|$$">$$</button>
                <button class="custom-formula-shortcut-btn" data-code="$|$">$</button>
                <button class="custom-formula-shortcut-btn" data-code="\frac{|}{}">\frac{}{}</button>
                <button class="custom-formula-shortcut-btn" data-code="\vec{|}">\vec{}</button>
                <button class="custom-formula-shortcut-btn" data-code="\quad">\quad</button>
                <button class="custom-formula-shortcut-btn" data-code="\sqrt{|}">\sqrt{}</button>
                <button class="custom-formula-shortcut-btn" data-code="\sum">\sum</button>
                <button class="custom-formula-shortcut-btn" data-code="\int">\int</button>
                <button class="custom-formula-shortcut-btn" data-code="\alpha">\alpha</button>
                <button class="custom-formula-shortcut-btn" data-code="\beta">\beta</button>
                <button class="custom-formula-shortcut-btn" data-code="\gamma">\gamma</button>
            </div>
            <div class="custom-formula-form-group">
                <label for="custom-formula-manual-formula-input">Enter your goals:</label>
                <textarea id="custom-formula-manual-formula-input" placeholder="e.g., f(x) = x^2" rows="3"></textarea>
                <p><small>Tip: Separate multiple goals with an emoji (e.g., ðŸš€, âœ¨, ðŸ’¡)</small></p>
            </div>
            <button id="custom-formula-add-formula-btn" class="custom-formula-btn">Add Goals</button>
        </div>

        <div class="custom-formula-card text-center">
            <h2>Timer</h2>
            <div id="custom-formula-timer-display-box" class="custom-formula-timer-box">
                <button id="custom-formula-timer-display" class="custom-formula-timer-display-btn" aria-label="Set timer duration">00:25:00</button>
            </div>
            <div class="custom-formula-timer-controls">
                <button id="custom-formula-start-timer-btn" class="custom-formula-btn">Start</button>
                <button id="custom-formula-stop-timer-btn" class="custom-formula-btn custom-formula-btn-secondary">Stop</button>
                <button id="custom-formula-reset-timer-btn" class="custom-formula-btn custom-formula-btn-secondary">Reset</button>
            </div>
        </div>

        <div class="custom-formula-progress-section custom-formula-card">
            <h2>Your Progress</h2>
            <div class="custom-formula-progress-bar-container">
                <div class="custom-formula-progress-bar" id="custom-formula-progress-bar"></div>
            </div>
            <div id="custom-formula-progress-text" aria-live="polite">0% Completed</div>
        </div>

        <div id="custom-formula-formula-container">
            <div id="custom-formula-formula-list-header">
                <h2 id="custom-formula-session-category-heading"></h2>
                <h3 id="custom-formula-session-subcategory-heading"></h3>
            </div>
            <ul id="custom-formula-formula-list"></ul>
        </div>

        <div class="custom-formula-card text-center">
             <button id="custom-formula-save-progress-btn" class="custom-formula-btn">Save Progress</button>
             <button id="custom-formula-clear-btn" class="custom-formula-btn custom-formula-btn-secondary custom-formula-ml-1">Clear</button>
        </div>
    </div>

    <div id="custom-formula-saved-data-view" class="custom-formula-container d-none">
        <!-- Saved data content will be injected here -->
    </div>

    <div id="custom-formula-uncompleted-data-view" class="custom-formula-container d-none">
        <!-- Uncompleted formulas content will be injected here -->
    </div>

    <div id="custom-formula-failed-data-view" class="custom-formula-container d-none">
        <!-- Failed sessions content will be injected here -->
    </div>


    <div class="custom-formula-modal-overlay" id="custom-formula-celebration-modal">
            <div class="custom-formula-modal-content" role="alertdialog" aria-labelledby="custom-formula-celebration-title">
            <span>ðŸŽ‰</span>
                <h2 id="custom-formula-celebration-title">Goal Achieved!</h2>
        </div>
    </div>

    <div class="custom-formula-modal-overlay" id="custom-formula-ocr-progress-modal">
        <div class="custom-formula-modal-content" role="dialog" aria-modal="true" aria-labelledby="custom-formula-ocr-title" aria-busy="true">
            <h2 id="custom-formula-ocr-title">Processing Image</h2>
            <p id="custom-formula-ocr-progress-status" aria-live="polite">Initializing...</p>
            <div class="custom-formula-progress-bar-container">
                <div class="custom-formula-progress-bar" id="custom-formula-ocr-progress-bar"></div>
            </div>
        </div>
    </div>

    <div class="custom-formula-modal-overlay" id="custom-formula-save-modal">
        <div class="custom-formula-modal-content" role="dialog" aria-modal="true" aria-labelledby="custom-formula-save-title">
            <h2 id="custom-formula-save-title">Save Progress</h2>
            <div class="custom-formula-form-group">
                <label for="custom-formula-category-input">Category</label>
                <input type="text" id="custom-formula-category-input" placeholder="e.g., Physics 101">
            </div>
            <div class="custom-formula-form-group">
                <label for="custom-formula-subcategory-input">Sub-category</label>
                <input type="text" id="custom-formula-subcategory-input" placeholder="e.g., Kinematics">
            </div>
            <button id="custom-formula-save-modal-btn" class="custom-formula-btn">Save</button>
                <button id="custom-formula-cancel-save-btn" class="custom-formula-btn custom-formula-btn-secondary custom-formula-ml-1">Cancel</button>
        </div>
    </div>

    <div class="custom-formula-modal-overlay" id="custom-formula-clear-modal">
        <div class="custom-formula-modal-content" role="dialog" aria-modal="true" aria-labelledby="custom-formula-clear-title">
            <h2 id="custom-formula-clear-title">Clear Formulas</h2>
            <p>Select the formulas you want to clear, or clear all.</p>
            <p><small>This only clears goals from your current session. Saved data will not be affected.</small></p>
            <ul id="custom-formula-clear-formula-list">
                <!-- Formulas will be populated here by JS -->
            </ul>
            <div class="custom-formula-modal-actions">
                <button id="custom-formula-clear-selected-btn" class="custom-formula-btn">Clear Selected</button>
                <button id="custom-formula-clear-all-btn" class="custom-formula-btn custom-formula-btn-secondary">Clear All</button>
                <button id="custom-formula-cancel-clear-btn" class="custom-formula-btn custom-formula-btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div class="custom-formula-modal-overlay" id="custom-formula-timer-modal">
        <div class="custom-formula-modal-content" role="dialog" aria-modal="true" aria-labelledby="custom-formula-timer-title">
            <h2 id="custom-formula-timer-title">Set Timer Duration</h2>
            <div class="timer">
                <div class="reel" data-max="23"></div>
                <div class="colon">:</div>
                <div class="reel" data-max="59"></div>
                <div class="colon">:</div>
                <div class="reel" data-max="59"></div>
            </div>
            <div class="custom-formula-modal-actions">
                <button id="custom-formula-set-timer-btn" class="custom-formula-btn">Set</button>
                <button id="custom-formula-cancel-timer-btn" class="custom-formula-btn custom-formula-btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div class="custom-formula-modal-overlay" id="custom-formula-notification-modal">
        <div class="custom-formula-modal-content" role="alertdialog" aria-labelledby="custom-formula-notification-title">
            <h2 id="custom-formula-notification-title"></h2>
            <p id="custom-formula-notification-message" aria-live="polite"></p>
            <div class="custom-formula-spinner"></div>
            <div class="custom-formula-modal-actions">
                 <button id="custom-formula-notification-close-btn" class="custom-formula-btn">OK</button>
            </div>
        </div>
    </div>

    <div class="custom-formula-modal-overlay" id="custom-formula-confirmation-modal">
        <div class="custom-formula-modal-content" role="dialog" aria-modal="true" aria-labelledby="custom-formula-confirmation-title">
            <h2 id="custom-formula-confirmation-title"></h2>
            <p id="custom-formula-confirmation-message" aria-live="assertive"></p>
            <div class="custom-formula-modal-actions">
                <button id="custom-formula-confirmation-confirm-btn" class="custom-formula-btn">Confirm</button>
                <button id="custom-formula-confirmation-cancel-btn" class="custom-formula-btn custom-formula-btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div class="custom-formula-modal-overlay" id="custom-formula-add-subgoal-modal">
        <div class="custom-formula-modal-content" role="dialog" aria-modal="true" aria-labelledby="custom-formula-add-subgoal-title">
            <h2 id="custom-formula-add-subgoal-title">Add Subgoal</h2>
            <div class="custom-formula-shortcuts">
                <button class="custom-formula-shortcut-btn" data-code="\">\</button>
                <button class="custom-formula-shortcut-btn" data-code="\[|\]">&lbrack;\]</button>
                <button class="custom-formula-shortcut-btn" data-code="\text{|}">\text{}</button>
                <button class="custom-formula-shortcut-btn" data-code="~">~</button>
                <button class="custom-formula-shortcut-btn" data-code="$$|$$">$$</button>
                <button class="custom-formula-shortcut-btn" data-code="$|$">$</button>
                <button class="custom-formula-shortcut-btn" data-code="\frac{|}{}">\frac{}{}</button>
                <button class="custom-formula-shortcut-btn" data-code="\vec{|}">\vec{}</button>
                <button class="custom-formula-shortcut-btn" data-code="\quad">\quad</button>
                <button class="custom-formula-shortcut-btn" data-code="\sqrt{|}">\sqrt{}</button>
                <button class="custom-formula-shortcut-btn" data-code="\sum">\sum</button>
                <button class="custom-formula-shortcut-btn" data-code="\int">\int</button>
                <button class="custom-formula-shortcut-btn" data-code="\alpha">\alpha</button>
                <button class="custom-formula-shortcut-btn" data-code="\beta">\beta</button>
                <button class="custom-formula-shortcut-btn" data-code="\gamma">\gamma</button>
            </div>
            <div class="custom-formula-form-group">
                <label for="custom-formula-subgoal-input">Subgoal</label>
                <textarea id="custom-formula-subgoal-input" placeholder="e.g., Review chapter 1 notes" rows="3"></textarea>
            </div>
            <div class="custom-formula-modal-actions">
                <button id="custom-formula-save-subgoal-btn" class="custom-formula-btn">Save</button>
                <button id="custom-formula-cancel-subgoal-btn" class="custom-formula-btn custom-formula-btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div class="custom-formula-modal-overlay" id="custom-formula-export-modal">
        <div class="custom-formula-modal-content" role="dialog" aria-modal="true" aria-labelledby="custom-formula-export-title">
            <h2 id="custom-formula-export-title">Export Session</h2>
            <p>Choose how you want to export this session:</p>
            <div style="display: flex; flex-direction: column; gap: 1rem; margin-top: 1rem;">
                <button id="custom-formula-export-text-btn" class="custom-formula-btn">TEXT</button>
                <button id="custom-formula-export-pdf-btn" class="custom-formula-btn">PDF</button>
                <button id="custom-formula-export-image-btn" class="custom-formula-btn">IMAGE</button>
                <button id="custom-formula-cancel-export-btn" class="custom-formula-btn custom-formula-btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div class="custom-formula-modal-overlay" id="custom-formula-edit-header-modal">
        <div class="custom-formula-modal-content" role="dialog" aria-modal="true" aria-labelledby="custom-formula-edit-header-title">
            <h2 id="custom-formula-edit-header-title">Edit Name</h2>
            <div class="custom-formula-form-group">
                <input type="text" id="custom-formula-edit-header-input">
            </div>
            <div class="custom-formula-modal-actions">
                <button id="custom-formula-save-header-btn" class="custom-formula-btn">Save</button>
                <button id="custom-formula-cancel-header-btn" class="custom-formula-btn custom-formula-btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script type="module">
        (function() {
            document.addEventListener('DOMContentLoaded', () => {

            // --- IndexedDB Helper ---
            const idbHelper = {
                db: null,
                dbName: 'FormulaTrackerDB',
                storeName: 'KeyValueStore',
                version: 1,

                async openDB() {
                    if (this.db) return this.db;

                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.dbName, this.version);

                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains(this.storeName)) {
                                db.createObjectStore(this.storeName, { keyPath: 'key' });
                            }
                        };

                        request.onsuccess = (event) => {
                            this.db = event.target.result;
                            resolve(this.db);
                        };

                        request.onerror = (event) => {
                            console.error('IndexedDB error:', event.target.error);
                            reject(event.target.error);
                        };
                    });
                },

                async get(key) {
                    const db = await this.openDB();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(this.storeName, 'readonly');
                        const store = transaction.objectStore(this.storeName);
                        const request = store.get(key);

                        request.onsuccess = () => {
                            resolve(request.result ? request.result.value : undefined);
                        };
                        request.onerror = (event) => reject(event.target.error);
                    });
                },

                async set(key, value) {
                    const db = await this.openDB();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(this.storeName, 'readwrite');
                        const store = transaction.objectStore(this.storeName);
                        const request = store.put({ key, value });

                        request.onsuccess = () => resolve();
                        request.onerror = (event) => reject(event.target.error);
                    });
                },

                async delete(key) {
                    const db = await this.openDB();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(this.storeName, 'readwrite');
                        const store = transaction.objectStore(this.storeName);
                        const request = store.delete(key);

                        request.onsuccess = () => resolve();
                        request.onerror = (event) => reject(event.target.error);
                    });
                },

                async clear() {
                    const db = await this.openDB();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(this.storeName, 'readwrite');
                        const store = transaction.objectStore(this.storeName);
                        const request = store.clear();

                        request.onsuccess = () => resolve();
                        request.onerror = (event) => reject(event.target.error);
                    });
                }
            };

            // --- Safe localStorage access helper ---
            function getSafeLocalStorage() {
              try {
                // Accessing window.localStorage can throw in some webviews / privacy modes
                return window.localStorage;
              } catch (e) {
                return null;
              }
            }

            let mathJaxLoadPromise = null;
            function ensureMathJax() {
                if (mathJaxLoadPromise) {
                    return mathJaxLoadPromise;
                }

                mathJaxLoadPromise = new Promise(async (resolve, reject) => {
                    if (window.MathJax && window.MathJax.startup?.promise) {
                        try {
                            await window.MathJax.startup.promise;
                            resolve();
                        } catch(err) {
                            console.error('MathJax startup promise failed.', err);
                            showNotification('Error', 'Failed to initialize the formula rendering library.');
                            reject(err);
                        }
                    } else {
                        // If MathJax is not available after DOMContentLoaded, it's a loading failure.
                        console.error('MathJax script not loaded or failed to initialize.');
                        showNotification('Error', 'The formula rendering library did not load correctly.');
                        reject(new Error('MathJax not found'));
                    }
                });

                return mathJaxLoadPromise;
            }

            function saveToLocalStorage(key, value) {
                const ls = getSafeLocalStorage();
                if (!ls) {
                    console.warn(`localStorage unavailable â€” skipping save for key: ${key}`);
                    return false;
                }
                try {
                    ls.setItem(key, value);
                    return true;
                } catch (e) {
                    if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                        showNotification('Storage Error', 'Your browser storage is full. Please clear some data to continue saving progress.');
                    } else {
                        showNotification('Storage Error', 'An unknown error occurred while saving data.');
                    }
                    console.error(`Error saving to localStorage (${key}):`, e);
                    return false;
                }
            }

            async function saveAllFormulaData(data) {
                try {
                    await idbHelper.set('savedFormulaData', data);
                } catch (error) {
                    console.error('Failed to save formula data to IndexedDB:', error);
                    showNotification('Save Error', 'Could not save your progress to the database.');
                }
            }

            const imageUpload = document.getElementById('custom-formula-image-upload');
            const jsonUpload = document.getElementById('custom-formula-json-upload');
            const downloadExample = document.getElementById('custom-formula-download-example');
            const formulaList = document.getElementById('custom-formula-formula-list');
            const progressBar = document.getElementById('custom-formula-progress-bar');
            const progressText = document.getElementById('custom-formula-progress-text');
            const celebrationModal = document.getElementById('custom-formula-celebration-modal');
            const ocrProgressModal = document.getElementById('custom-formula-ocr-progress-modal');
            const ocrProgressBar = document.getElementById('custom-formula-ocr-progress-bar');
            const ocrProgressStatus = document.getElementById('custom-formula-ocr-progress-status');
            const saveProgressBtn = document.getElementById('custom-formula-save-progress-btn');
            const saveModal = document.getElementById('custom-formula-save-modal');
            const sandwichBtn = document.getElementById('custom-formula-sandwich-btn');
            const darkModeSwitch = document.getElementById('custom-formula-dark-mode-switch');
            const savedCategoriesList = document.getElementById('custom-formula-saved-categories-list');
            const saveModalBtn = document.getElementById('custom-formula-save-modal-btn');
            const categoryInput = document.getElementById('custom-formula-category-input');
            const subcategoryInput = document.getElementById('custom-formula-subcategory-input');
            const mainContainer = document.getElementById('custom-formula-main-container');
            const savedDataView = document.getElementById('custom-formula-saved-data-view');
            const clearBtn = document.getElementById('custom-formula-clear-btn');
            const clearModal = document.getElementById('custom-formula-clear-modal');
            const clearFormulaList = document.getElementById('custom-formula-clear-formula-list');
            const clearSelectedBtn = document.getElementById('custom-formula-clear-selected-btn');
            const clearAllBtn = document.getElementById('custom-formula-clear-all-btn');
            const cancelClearBtn = document.getElementById('custom-formula-cancel-clear-btn');
            const manualFormulaInput = document.getElementById('custom-formula-manual-formula-input');
            const addFormulaBtn = document.getElementById('custom-formula-add-formula-btn');
            const showUncompletedBtn = document.getElementById('custom-formula-show-uncompleted-btn');
            const uncompletedDataView = document.getElementById('custom-formula-uncompleted-data-view');
            const timerDisplay = document.getElementById('custom-formula-timer-display');
            const startTimerBtn = document.getElementById('custom-formula-start-timer-btn');
            const stopTimerBtn = document.getElementById('custom-formula-stop-timer-btn');
            const resetTimerBtn = document.getElementById('custom-formula-reset-timer-btn');
            const showFailedBtn = document.getElementById('custom-formula-show-failed-btn');
            const failedDataView = document.getElementById('custom-formula-failed-data-view');
            const allViews = [mainContainer, savedDataView, uncompletedDataView, failedDataView];
            const timerModal = document.getElementById('custom-formula-timer-modal');
            const setTimerBtn = document.getElementById('custom-formula-set-timer-btn');
            const cancelTimerBtn = document.getElementById('custom-formula-cancel-timer-btn');
            const formulaListHeader = document.getElementById('custom-formula-formula-list-header');
            const sessionCategoryHeading = document.getElementById('custom-formula-session-category-heading');
            const sessionSubcategoryHeading = document.getElementById('custom-formula-session-subcategory-heading');
            const notificationModal = document.getElementById('custom-formula-notification-modal');
            const notificationTitle = document.getElementById('custom-formula-notification-title');
            const notificationMessage = document.getElementById('custom-formula-notification-message');
            const notificationCloseBtn = document.getElementById('custom-formula-notification-close-btn');
            const confirmationModal = document.getElementById('custom-formula-confirmation-modal');
            const confirmationTitle = document.getElementById('custom-formula-confirmation-title');
            const confirmationMessage = document.getElementById('custom-formula-confirmation-message');
            const confirmationConfirmBtn = document.getElementById('custom-formula-confirmation-confirm-btn');
            const confirmationCancelBtn = document.getElementById('custom-formula-confirmation-cancel-btn');
            const exportBtn = document.getElementById('custom-formula-export-btn');
            const importBtn = document.getElementById('custom-formula-import-btn');
            const importFileInput = document.getElementById('custom-formula-import-file-input');
            const addSubgoalModal = document.getElementById('custom-formula-add-subgoal-modal');
            const subgoalInput = document.getElementById('custom-formula-subgoal-input');
            const saveSubgoalBtn = document.getElementById('custom-formula-save-subgoal-btn');
            const cancelSubgoalBtn = document.getElementById('custom-formula-cancel-subgoal-btn');

            const exportModal = document.getElementById('custom-formula-export-modal');
            const exportTextBtn = document.getElementById('custom-formula-export-text-btn');
            const exportPdfBtn = document.getElementById('custom-formula-export-pdf-btn');
            const exportImageBtn = document.getElementById('custom-formula-export-image-btn');
            const cancelExportBtn = document.getElementById('custom-formula-cancel-export-btn');
            let exportContext = { category: null, subcategory: null };

            const editHeaderModal = document.getElementById('custom-formula-edit-header-modal');
            const editHeaderInput = document.getElementById('custom-formula-edit-header-input');
            const saveHeaderBtn = document.getElementById('custom-formula-save-header-btn');
            const cancelHeaderBtn = document.getElementById('custom-formula-cancel-header-btn');
            let editHeaderContext = { type: null, originalValue: null };


            let longPressTimer;
            let currentGoalId = null;
            let isLongPress = false;
            let startX, startY;

            function createGoal(text) {
                return {
                    id: `goal-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    text: text,
                    completed: false,
                    subgoals: []
                };
            }

            function createSubgoal(text) {
                return {
                    id: `subgoal-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    text: text,
                    completed: false
                };
            }

            class Reel {
                constructor(el, max){
                    this.el = el;
                    this.max = max;
                    this.loopCount = this.max + 1; // number of unique values
                    this.total = this.loopCount * 3; // triple list: before, middle, after
                    this.inner = document.createElement('div');
                    this.inner.className = 'reel-inner';
                    this.el.appendChild(this.inner);

                    this.ITEM_H = 40;
                    this.VISIBLE = 3;
                    this.CENTER_OFFSET = (this.VISIBLE - 1) / 2 * this.ITEM_H; // used to center an item

                    this._build();

                    // position is the index in the repeated list that is currently centered
                    this.position = this.loopCount; // start at the first item of the middle block

                    // drag / momentum vars
                    this.isDragging = false;
                    this.lastY = 0;
                    this.lastTime = 0;
                    this.velocity = 0; // items per frame-ish
                    this.animFrame = null;
                    this._bind();

                    // set initial transform without transition
                    this._setTransform(false);
                    this._updateActive();
                }

                _build(){
                    // create three copies: 0..max, 0..max, 0..max
                    for(let r=0;r<3;r++){
                        for(let i=0;i<=this.max;i++){
                            const span = document.createElement('span');
                            span.textContent = String(i).padStart(2,'0');
                            this.inner.appendChild(span);
                        }
                    }
                }

                _bind(){
                    // use Pointer Events when available for unified handling
                    if(window.PointerEvent){
                        this.el.addEventListener('pointerdown', this._onPointerDown.bind(this));
                        window.addEventListener('pointermove', this._onPointerMove.bind(this));
                        window.addEventListener('pointerup', this._onPointerUp.bind(this));
                        this.el.addEventListener('pointercancel', this._onPointerUp.bind(this));
                    } else {
                        // fallback
                        this.el.addEventListener('touchstart', this._onTouchStart.bind(this), {passive:false});
                        window.addEventListener('touchmove', this._onTouchMove.bind(this), {passive:false});
                        window.addEventListener('touchend', this._onTouchEnd.bind(this));
                        this.el.addEventListener('mousedown', this._onMouseDown.bind(this));
                        window.addEventListener('mousemove', this._onMouseMove.bind(this));
                        window.addEventListener('mouseup', this._onMouseUp.bind(this));
                    }
                }

                // --- event handlers (pointer unified) ---
                _getClientY(e){
                    if(e.touches && e.touches[0]) return e.touches[0].clientY;
                    if(e.clientY !== undefined) return e.clientY;
                    return 0;
                }

                _onPointerDown(e){
                    e.preventDefault();
                    this.el.setPointerCapture && this.el.setPointerCapture(e.pointerId);
                    this._start(this._getClientY(e));
                }
                _onPointerMove(e){
                    if(!this.isDragging) return;
                    e.preventDefault();
                    this._move(this._getClientY(e));
                }
                _onPointerUp(e){
                    this._end();
                }

                // touch fallback
                _onTouchStart(e){ e.preventDefault(); this._start(this._getClientY(e)); }
                _onTouchMove(e){ if(!this.isDragging) return; e.preventDefault(); this._move(this._getClientY(e)); }
                _onTouchEnd(e){ this._end(); }

                // mouse fallback
                _onMouseDown(e){ e.preventDefault(); this._start(this._getClientY(e)); }
                _onMouseMove(e){ if(!this.isDragging) return; this._move(this._getClientY(e)); }
                _onMouseUp(e){ this._end(); }

                _start(y){
                    // cancel any running momentum so a new touch stops it immediately
                    if(this.animFrame) cancelAnimationFrame(this.animFrame);
                    this.animFrame = null;

                    this.isDragging = true;
                    this.lastY = y;
                    this.lastTime = performance.now();
                    this.velocity = 0;

                    // remove transition so movement follows finger exactly
                    this.inner.style.transition = 'none';
                }

                _move(y){
                    const now = performance.now();
                    const dy = y - this.lastY; // px
                    const dt = Math.max(1, now - this.lastTime);

                    // map pixel movement to "items" movement (positive when dragging up -> increase value)
                    const deltaItems = -dy / this.ITEM_H; // negative dy (drag up) -> positive deltaItems

                    // update position and track a velocity in items per frame
                    this.position += deltaItems;
                    this._wrap();
                    this._setTransform(false);

                    // velocity smoothing (items per ms converted to items per frame scale)
                    // use an adaptive estimate: instantaneous items / ms scaled to per-frame (~16ms)
                    const instVel = deltaItems / dt * 16.66; // approximate items / 16.66ms
                    this.velocity = instVel * 0.85 + this.velocity * 0.15; // low-pass filter

                    this.lastY = y;
                    this.lastTime = now;
                }

                _end(){
                    if(!this.isDragging) return;
                    this.isDragging = false;
                    // start momentum with friction
                    this._startMomentum();
                }

                _startMomentum(){
                    const friction = 0.94; // tweak for snappier or longer glide
                    const minVel = 0.02; // threshold to stop and snap

                    const step = () => {
                        // apply velocity
                        this.position += this.velocity;
                        this._wrap();
                        this._setTransform(false);

                        // decay
                        this.velocity *= friction;

                        if(Math.abs(this.velocity) > minVel){
                            this.animFrame = requestAnimationFrame(step);
                        } else {
                            this.animFrame = null;
                            // snap to nearest integer (center item) with a short transition
                            this._snap();
                        }
                    };

                    // kick off
                    if(Math.abs(this.velocity) > minVel) this.animFrame = requestAnimationFrame(step);
                    else this._snap();
                }

                _snap(){
                    this.position = Math.round(this.position);
                    this._setTransform(true);
                    this._updateActive();
                    // clear transition after it finishes so future immediate drags aren't affected
                    const onEnd = () => { this.inner.style.transition = 'none'; this.inner.removeEventListener('transitionend', onEnd); };
                    this.inner.addEventListener('transitionend', onEnd);
                }

                _wrap(){
                    // keep position inside middle block [loopCount, loopCount*2)
                    const L = this.loopCount;
                    while(this.position < L) this.position += L;
                    while(this.position >= L*2) this.position -= L;
                }

                _setTransform(withTransition){
                    if(withTransition) this.inner.style.transition = 'transform 220ms cubic-bezier(.22,.9,.35,1)';
                    const y = this.CENTER_OFFSET - (this.position * this.ITEM_H);
                    this.inner.style.transform = `translateY(${y}px)`;
                    this._updateActive();
                }

                _updateActive(){
                    const spans = this.inner.children;
                    const idx = Math.round(this.position); // should be inside middle block range
                    for(let i=0;i<spans.length;i++) spans[i].classList.remove('active');
                    if(spans[idx]) spans[idx].classList.add('active');
                }

                // helper to read the currently selected value (0..max)
                getValue(){
                    return Math.round(this.position) % this.loopCount;
                }

                setValue(value) {
                    const targetPosition = this.loopCount + (value % this.loopCount);
                    this.position = targetPosition;
                    this._setTransform(true);
                }
            }

            // init reels
            const reels = [];
            document.querySelectorAll('.reel').forEach(el=>{
                const max = parseInt(el.dataset.max,10)||59;
                reels.push(new Reel(el,max));
            });
            window.customFormulaReels = reels;

            let formulas = []; // Now an array of objects: {id: string, text: string, completed: bool, subgoals: Array}
            let parsedFormulas = [];
            let sessionCategory = '';
            let sessionSubcategory = '';
            let isEditing = false; // Add this line

            // --- UI Rendering ---

            function renderSessionHeader() {
                if (sessionCategory && sessionSubcategory) {
                    sessionCategoryHeading.textContent = sessionCategory;
                    sessionSubcategoryHeading.textContent = sessionSubcategory;
                    formulaListHeader.style.display = 'block';

                    // Make headers clickable
                    sessionCategoryHeading.style.cursor = 'pointer';
                    sessionCategoryHeading.title = 'Click to edit Category';
                    sessionSubcategoryHeading.style.cursor = 'pointer';
                    sessionSubcategoryHeading.title = 'Click to edit Subcategory';
                } else {
                    formulaListHeader.style.display = 'none';
                }
            }

            sessionCategoryHeading.addEventListener('click', () => {
                openEditHeaderModal('category');
            });

            sessionSubcategoryHeading.addEventListener('click', () => {
                openEditHeaderModal('subcategory');
            });

            function openEditHeaderModal(type) {
                editHeaderContext.type = type;
                if (type === 'category') {
                    editHeaderContext.originalValue = sessionCategory;
                    editHeaderInput.value = sessionCategory;
                    document.getElementById('custom-formula-edit-header-title').textContent = "Edit Category";
                } else {
                    editHeaderContext.originalValue = sessionSubcategory;
                    editHeaderInput.value = sessionSubcategory;
                    document.getElementById('custom-formula-edit-header-title').textContent = "Edit Subcategory";
                }
                editHeaderModal.classList.add('custom-formula-show');
                editHeaderInput.focus();
            }

            saveHeaderBtn.addEventListener('click', async () => {
                const newValue = editHeaderInput.value.trim();
                const { type, originalValue } = editHeaderContext;

                if (!newValue) {
                    showNotification('Error', 'Name cannot be empty.');
                    return;
                }

                if (newValue === originalValue) {
                    editHeaderModal.classList.remove('custom-formula-show');
                    return;
                }

                if (!isEditing) {
                    // Simple rename for unsaved session
                    if (type === 'category') {
                        sessionCategory = newValue;
                    } else {
                        sessionSubcategory = newValue;
                    }
                    saveFormulasToLocalStorage();
                    renderSessionHeader();
                    editHeaderModal.classList.remove('custom-formula-show');
                } else {
                    // Editing a saved session - requires DB move
                    editHeaderModal.classList.remove('custom-formula-show');

                    const message = type === 'category'
                        ? `Rename Category from "${originalValue}" to "${newValue}"?`
                        : `Rename Subcategory from "${originalValue}" to "${newValue}"?`;

                    const subMessage = `This will move all data to the new location and delete the old "${originalValue}" entry.`;

                    const confirmed = await showConfirmation('Confirm Rename', `${message}\n${subMessage}`);

                    if (confirmed) {
                        await performDatabaseMove(type, originalValue, newValue);
                    }
                }
            });

            cancelHeaderBtn.addEventListener('click', () => {
                editHeaderModal.classList.remove('custom-formula-show');
            });

            async function performDatabaseMove(type, oldVal, newVal) {
                const savedData = await idbHelper.get('savedFormulaData') || {};

                // Determine source path
                const oldCat = type === 'category' ? oldVal : sessionCategory;
                const oldSub = type === 'category' ? sessionSubcategory : oldVal;

                // Determine target path
                const newCat = type === 'category' ? newVal : sessionCategory;
                const newSub = type === 'category' ? sessionSubcategory : newVal;

                // 1. Get current in-memory data (representing the 'Edit' state)
                const currentData = JSON.parse(JSON.stringify(formulas));

                // 2. Check if target location exists to merge
                if (!savedData[newCat]) savedData[newCat] = {};

                if (savedData[newCat][newSub]) {
                    // Merge logic: append current items to existing items
                    // Filter duplicates based on text
                    const existingItems = savedData[newCat][newSub];
                    const existingTexts = new Set(existingItems.map(i => i.text));

                    currentData.forEach(item => {
                        if (!existingTexts.has(item.text)) {
                            existingItems.push(item);
                        } else {
                            // Update existing item status if current is completed?
                            // For simplicity in a "Move" operation, we generally prioritize the active session state
                            // but if we are merging into a *different* existing bucket, we should probably just add missing ones.
                            // However, the user said "that session should go under that subcategory".
                            // Let's just append non-duplicates.
                        }
                    });

                    // We update formulas to reflect the MERGED state so the UI updates
                    formulas = existingItems;
                } else {
                    // Target doesn't exist, just assign
                    savedData[newCat][newSub] = currentData;
                }

                // 3. Delete old location
                if (savedData[oldCat] && savedData[oldCat][oldSub]) {
                    delete savedData[oldCat][oldSub];
                    // Clean up empty category
                    if (Object.keys(savedData[oldCat]).length === 0) {
                        delete savedData[oldCat];
                    }
                }

                // 4. Save DB
                await saveAllFormulaData(savedData);

                // 5. Update State
                sessionCategory = newCat;
                sessionSubcategory = newSub;

                // 6. Update UI & LocalStorage
                saveFormulasToLocalStorage();
                renderSessionHeader();
                renderFormulas(); // Re-render in case of merge
                await renderSavedCategories(); // Update sidebar

                showNotification('Success', 'Session renamed and moved successfully.');
            }

            // --- Persistence ---

            /**
             * Saves the currently active session (formulas, category, subcategory) to localStorage.
             * This is for short-term persistence, allowing the user to refresh the page
             * without losing their current work-in-progress. This data is cleared once the
             * session is formally saved or completed.
             */
            function saveFormulasToLocalStorage() {
                saveToLocalStorage('custom-formula-formulas', JSON.stringify(formulas));
                saveToLocalStorage('custom-formula-sessionCategory', sessionCategory);
                saveToLocalStorage('custom-formula-sessionSubcategory', sessionSubcategory);
            }

            function loadFormulasFromLocalStorage() {
              const ls = getSafeLocalStorage();
              if (!ls) {
                console.warn('localStorage unavailable â€” skipping session restore.');
                return;
              }

              try {
                const storedFormulas = ls.getItem('custom-formula-formulas');
                if (storedFormulas && storedFormulas !== '[]') {
                  const loadedFormulas = JSON.parse(storedFormulas);
                  formulas = loadedFormulas.map(f => {
                    if (f && typeof f === 'object' && f.id && Array.isArray(f.subgoals)) {
                      return f;
                    }
                    const text = (typeof f === 'object' && f !== null) ? f.text : String(f);
                    return createGoal(text || '');
                  }).filter(f => f.text);

                  sessionCategory = ls.getItem('custom-formula-sessionCategory') || '';
                  sessionSubcategory = ls.getItem('custom-formula-sessionSubcategory') || '';
                  renderFormulas();
                  renderSessionHeader();
                }
              } catch (e) {
                console.warn('Error reading saved session from localStorage:', e);
              }
            }

            // --- Timer Logic ---
            let timerState = {
                status: 'stopped', // 'running', 'paused', 'stopped'
                duration: 25 * 60 * 1000, // Default 25 minutes in ms
                remaining: 25 * 60 * 1000,
                lastUpdated: 0
            };
            let timerInterval = null;
            let timerFinishTimeout = null;

            function saveTimerState() {
                saveToLocalStorage('custom-formula-timerState', JSON.stringify(timerState));
            }

            function loadTimerState() {
              const ls = getSafeLocalStorage();
              if (!ls) return null;

              try {
                const storedState = ls.getItem('custom-formula-timerState');
                if (storedState) {
                  const parsedState = JSON.parse(storedState);
                  if (typeof parsedState === 'object' && parsedState !== null &&
                      'status' in parsedState &&
                      'duration' in parsedState &&
                      'remaining' in parsedState &&
                      'lastUpdated' in parsedState) {
                    return parsedState;
                  } else {
                    console.warn("Invalid timer state found in localStorage. Ignoring.", parsedState);
                    return null;
                  }
                }
              } catch (e) {
                console.error("Error loading timer state from localStorage (possibly inaccessible):", e);
              }
              return null;
            }

            function updateTimerDisplay(timeInSeconds) {
                const totalSeconds = Math.floor(timeInSeconds);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                timerDisplay.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            function startTimerIntervals(remainingMs) {
                if (timerInterval) {
                    clearInterval(timerInterval);
                    clearTimeout(timerFinishTimeout);
                }

                const start = Date.now();
                updateTimerDisplay(remainingMs / 1000);

                timerInterval = setInterval(() => {
                    const elapsed = Date.now() - start;
                    const currentRemaining = remainingMs - elapsed;
                    if (currentRemaining > 0) {
                        updateTimerDisplay(currentRemaining / 1000);
                    } else {
                        updateTimerDisplay(0);
                        clearInterval(timerInterval);
                    }
                }, 1000);

                timerFinishTimeout = setTimeout(() => {
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                        handleTimerFinish();
                    }
                }, remainingMs);
            }

            function updateTimerUI(state) {
                if (!state) return;
                timerState = state;

                // Clear any existing intervals before setting new ones
                clearInterval(timerInterval);
                clearTimeout(timerFinishTimeout);
                timerInterval = null;
                timerFinishTimeout = null;

                if (state.status === 'running') {
                    const elapsedSinceUpdate = Date.now() - state.lastUpdated;
                    const currentRemaining = state.remaining - elapsedSinceUpdate;

                    if (currentRemaining > 0) {
                        updateTimerDisplay(currentRemaining / 1000);
                        startTimerIntervals(currentRemaining);
                    } else {
                        handleTimerFinish();
                    }

                    startTimerBtn.disabled = true;
                    stopTimerBtn.textContent = 'Pause';
                    stopTimerBtn.disabled = false;
                } else if (state.status === 'paused') {
                    updateTimerDisplay(state.remaining / 1000);
                    startTimerBtn.disabled = true;
                    stopTimerBtn.textContent = 'Resume';
                    stopTimerBtn.disabled = false;
                } else if (state.status === 'completed') {
                    updateTimerDisplay(0);
                    startTimerBtn.disabled = false;
                    stopTimerBtn.textContent = 'Pause';
                    stopTimerBtn.disabled = true;
                } else { // 'stopped'
                    updateTimerDisplay(state.duration / 1000);
                    startTimerBtn.disabled = false;
                    stopTimerBtn.textContent = 'Pause';
                    stopTimerBtn.disabled = true;
                }
            }

            function handleTimerFinish() {
                timerState.status = 'completed';
                saveTimerState();
                handleFailedSession(); // This function already exists
            }

            function startTimer() {
                if (timerState.status === 'running') return;

                timerState.status = 'running';
                timerState.remaining = timerState.duration;
                timerState.lastUpdated = Date.now();
                saveTimerState();

                startTimerBtn.disabled = true;
                stopTimerBtn.textContent = 'Pause';
                stopTimerBtn.disabled = false;

                startTimerIntervals(timerState.duration);
            }

            function pauseTimer() {
                if (timerState.status !== 'running') return;

                clearInterval(timerInterval);
                clearTimeout(timerFinishTimeout);
                timerInterval = null;
                timerFinishTimeout = null;

                const elapsed = Date.now() - timerState.lastUpdated;
                timerState.remaining = Math.max(0, timerState.remaining - elapsed);
                timerState.status = 'paused';
                timerState.lastUpdated = Date.now();
                saveTimerState();

                startTimerBtn.disabled = true;
                stopTimerBtn.textContent = 'Resume';
            }

            function resumeTimer() {
                if (timerState.status !== 'paused') return;

                timerState.status = 'running';
                timerState.lastUpdated = Date.now();
                saveTimerState();

                startTimerBtn.disabled = true;
                stopTimerBtn.textContent = 'Pause';

                startTimerIntervals(timerState.remaining);
            }

            function resetTimer() {
                clearInterval(timerInterval);
                clearTimeout(timerFinishTimeout);
                timerInterval = null;
                timerFinishTimeout = null;

                timerState.status = 'stopped';
                timerState.remaining = timerState.duration;
                saveTimerState();

                updateTimerDisplay(timerState.duration / 1000);
                startTimerBtn.disabled = false;
                stopTimerBtn.textContent = 'Pause';
                stopTimerBtn.disabled = true;
            }

            timerDisplay.addEventListener('click', () => {
                const durationSeconds = timerState.duration / 1000;
                const hours = Math.floor(durationSeconds / 3600);
                const minutes = Math.floor((durationSeconds % 3600) / 60);
                const seconds = durationSeconds % 60;

                window.customFormulaReels[0].setValue(hours);
                window.customFormulaReels[1].setValue(minutes);
                window.customFormulaReels[2].setValue(seconds);

                timerModal.classList.add('custom-formula-show');
            });

            cancelTimerBtn.addEventListener('click', () => {
                timerModal.classList.remove('custom-formula-show');
            });

            setTimerBtn.addEventListener('click', () => {
                const hours = window.customFormulaReels[0].getValue();
                const minutes = window.customFormulaReels[1].getValue();
                const seconds = window.customFormulaReels[2].getValue();
                const totalMilliseconds = ((hours * 3600) + (minutes * 60) + seconds) * 1000;

                if (totalMilliseconds <= 0) {
                    showNotification('Invalid Duration', 'Please set a duration greater than 0 seconds.');
                    return;
                }
                timerState.duration = totalMilliseconds;
                timerState.remaining = totalMilliseconds;
                updateTimerDisplay(totalMilliseconds / 1000);
                saveTimerState();
                timerModal.classList.remove('custom-formula-show');
            });

            startTimerBtn.addEventListener('click', () => {
                startTimer();
            });

            stopTimerBtn.addEventListener('click', () => {
                if (timerState.status === 'running') {
                    pauseTimer();
                } else if (timerState.status === 'paused') {
                    resumeTimer();
                }
            });

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && timerState.status === 'running') {
                    console.log('[TIMER_LOG] Tab became visible, re-syncing timer.');

                    const elapsed = Date.now() - timerState.lastUpdated;
                    const newRemaining = timerState.remaining - elapsed;

                    if (newRemaining > 100) {
                        timerState.remaining = newRemaining;
                        timerState.startTime = Date.now();
                        timerState.lastUpdated = Date.now();
                        saveTimerState();
                        startTimerIntervals(newRemaining);
                    } else {
                        handleTimerFinish();
                    }
                }
            });

            window.addEventListener('storage', (e) => {
                if (e.key === 'custom-formula-timerState') {
                    console.log('[TIMER_LOG] Storage event detected. Syncing timer state across tabs.');
                    const newState = JSON.parse(e.newValue);
                    if (newState) {
                        updateTimerUI(newState);
                    }
                }
            });
            resetTimerBtn.addEventListener('click', resetTimer);


            // --- Import/Export ---

            async function exportData() {
              const dataToExport = {
                indexedDB: {},
                localStorage: {}
              };

              // Get IndexedDB data
              const formulaData = await idbHelper.get('savedFormulaData');
              if (formulaData) dataToExport.indexedDB['savedFormulaData'] = formulaData;

              // Safe localStorage export
              const ls = getSafeLocalStorage();
              if (ls) {
                try {
                  const prefix = 'custom-formula-';
                  for (let i = 0; i < ls.length; i++) {
                    const key = ls.key(i);
                    if (key && key.startsWith(prefix)) {
                      dataToExport.localStorage[key] = ls.getItem(key);
                    }
                  }
                } catch (e) {
                  console.warn('Failed to read some localStorage keys during export:', e);
                }
              } else {
                // localStorage unavailable â€” warn user but still export IndexedDB data
                showNotification('Partial Export', 'localStorage is unavailable in this environment â€” exporting IndexedDB data only.');
              }

              if (Object.keys(dataToExport.indexedDB).length === 0 && Object.keys(dataToExport.localStorage).length === 0) {
                showNotification('No Data', 'There is no application data to export.');
                return;
              }

              const jsonString = JSON.stringify(dataToExport, null, 2);
              const blob = new Blob([jsonString], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
              a.download = `formula-tracker-backup-${timestamp}.json`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }

            exportBtn.addEventListener('click', async () => {
                const confirmed = await showConfirmation(
                    'Confirm Export',
                    'Are you sure you want to export all your data? This will create a backup file on your device.',
                    'Export',
                    'Cancel'
                );
                if (confirmed) {
                    await exportData();
                }
            });

            function importData(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    let importedData;
                    try {
                        importedData = JSON.parse(e.target.result);
                    } catch (error) {
                        showNotification('Import Error', 'The selected file is not valid JSON.');
                        return;
                    }

                    if (typeof importedData !== 'object' || importedData === null || (!importedData.indexedDB && !importedData.localStorage)) {
                        showNotification('Import Error', 'The backup file has an invalid format or is empty.');
                        return;
                    }

                    const confirmed = await showConfirmation(
                        'Confirm Import',
                        'Are you sure you want to import this data? This will overwrite all current settings and progress.',
                        'Import',
                        'Cancel'
                    );

                    if (confirmed) {
                        // Clear existing data
                        await idbHelper.clear();
                        const ls = getSafeLocalStorage();
                        if (ls) {
                          const keysToRemove = [];
                          for (let i = 0; i < ls.length; i++) {
                            const key = ls.key(i);
                            if (key && key.startsWith('custom-formula-')) keysToRemove.push(key);
                          }
                          keysToRemove.forEach(key => ls.removeItem(key));
                        } else {
                          console.warn('localStorage unavailable â€” skipping localStorage clear during import.');
                        }

                        // Import new data
                        if (importedData.indexedDB) {
                            for (const key in importedData.indexedDB) {
                                await idbHelper.set(key, importedData.indexedDB[key]);
                            }
                        }
                        if (importedData.localStorage) {
                            for (const key in importedData.localStorage) {
                                saveToLocalStorage(key, importedData.localStorage[key]);
                            }
                        }

                        showNotification('Success', 'Data imported successfully. The application will now reload.');

                        setTimeout(() => {
                            location.reload();
                        }, 2000);
                    }
                };

                reader.onerror = () => {
                    console.error("FileReader error.", reader.error);
                    showNotification('Import Error', 'An error occurred while trying to read the selected file.');
                };

                reader.readAsText(file);
                event.target.value = '';
            }

            importBtn.addEventListener('click', () => {
                importFileInput.click();
            });

            importFileInput.addEventListener('change', importData);


            // --- File Handlers ---

            function processJsonFile(file) {
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const jsonFormulaStrings = JSON.parse(event.target.result);
                        if (Array.isArray(jsonFormulaStrings)) {
                            // This check is important to ensure we're not processing a backup file
                            if (jsonFormulaStrings.every(item => typeof item === 'string')) {
                                parsedFormulas = jsonFormulaStrings.map(f => createGoal(String(f)));
                                saveModal.classList.add('custom-formula-show'); // Ask for category upfront
                            } else {
                                showNotification('JSON Error', 'The JSON file does not appear to be a simple list of goals. For full backups, please use the "Import All Data" feature in the sidebar.');
                            }
                        } else {
                            showNotification('JSON Error', 'JSON file should contain a simple array of strings.');
                        }
                    } catch (error) {
                        showNotification('JSON Error', 'Error parsing JSON file.');
                        console.error(error);
                    }
                };
                reader.onerror = () => {
                     showNotification('File Error', 'Could not read the selected JSON file.');
                };
                reader.readAsText(file);
            }

            imageUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    runOCR(file);
                }
                e.target.value = ''; // Reset file input
            });

            jsonUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    processJsonFile(file);
                }
                e.target.value = ''; // Reset file input
            });

            downloadExample.addEventListener('click', (e) => {
                e.preventDefault();
                const example = [
                    "E = mc^2",
                    "\\frac{1}{2}mv^2",
                    "a^2 + b^2 = c^2",
                    "\\int_0^\\infty e^{-x^2} dx = \\frac{\\sqrt{\\pi}}{2}",
                    "\\sum_{n=1}^\\infty \\frac{1}{n^2} = \\frac{\\pi^2}{6}"
                ];
                const jsonString = JSON.stringify(example, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'formulas_example.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            // --- OCR ---

            async function runOCR(file) {
                const ocrStatusMap = {
                    'loading tesseract core': 'Loading Core Engine...',
                    'initializing tesseract': 'Initializing Engine...',
                    'initialized tesseract': 'Engine Ready.',
                    'loading language traineddata': 'Loading Language Data...',
                    'loaded language traineddata': 'Language Ready.',
                    'recognizing text': 'Analyzing Image...'
                };

                ocrProgressModal.classList.add('custom-formula-show');
                ocrProgressBar.style.width = '0%';
                ocrProgressStatus.textContent = 'Loading OCR Engine...';

                try {
                    const worker = await Tesseract.createWorker('eng', 1, {
                        logger: m => {
                            const friendlyStatus = ocrStatusMap[m.status];
                            if (m.status === 'recognizing text') {
                                const progress = Math.round(m.progress * 100);
                                ocrProgressBar.style.width = `${progress}%`;
                                ocrProgressStatus.textContent = `Analyzing Image... ${progress}%`;
                            } else if (friendlyStatus) {
                                ocrProgressStatus.textContent = friendlyStatus;
                            } else {
                                console.log(`Unhandled OCR status: ${m.status}`);
                            }
                        }
                    });

                    const { data } = await worker.recognize(file);
                    await worker.terminate();
                    ocrProgressModal.classList.remove('custom-formula-show');

                    const lines = data.lines.map(line => line.text.trim()).filter(line => line.length > 0);
                    parsedFormulas = lines.map(line => createGoal(line));
                    saveModal.classList.add('custom-formula-show');
                } catch (error) {
                    console.error('OCR process failed:', error);
                    ocrProgressModal.classList.remove('custom-formula-show');

                    const confirmed = await showConfirmation(
                        'OCR Error',
                        'Failed to process the image. This could be due to a network issue or an unsupported image format. Would you like to try again?',
                        'Retry',
                        'Cancel'
                    );

                    if (confirmed) {
                        runOCR(file);
                    }
                }
            }

            // --- UI Rendering ---

            async function renderSavedCategories() {
                const savedData = await idbHelper.get('savedFormulaData') || {};
                savedCategoriesList.innerHTML = '';

                if (typeof savedData !== 'object' || savedData === null) {
                    console.warn("Invalid savedFormulaData format in IndexedDB. Expected object.", savedData);
                    savedCategoriesList.innerHTML = '<li>Error loading categories.</li>';
                    return;
                }

                const specialKeys = ["Uncompleted Sessions", "Failed Sessions"];
                const categories = Object.keys(savedData).filter(key => !specialKeys.includes(key));
                if (categories.length === 0) {
                    savedCategoriesList.innerHTML = '<li>No saved data yet.</li>';
                    return;
                }

                categories.forEach(category => {
                    const li = document.createElement('li');
                    const button = document.createElement('button');
                    button.textContent = category;
                    button.dataset.category = category;
                    button.className = 'custom-formula-sidebar-button';

                    li.appendChild(button);
                    savedCategoriesList.appendChild(li);
                });
            }

            async function showSavedDataView(category) {
                const savedData = await idbHelper.get('savedFormulaData') || {};
                const categoryData = savedData[category];
                if (!categoryData) {
                    showView('main');
                    await renderSavedCategories();
                    return;
                }
                showView('saved');
                savedDataView.innerHTML = ''; // Clear existing content

                const fragment = document.createDocumentFragment();

                // Header card
                const headerCard = document.createElement('div');
                headerCard.className = 'custom-formula-card';

                const headerFlex = document.createElement('div');
                headerFlex.style.display = 'flex';
                headerFlex.style.gap = '0.5rem';
                headerFlex.style.marginBottom = '1rem';

                const backBtn = document.createElement('button');
                backBtn.dataset.action = 'back-to-main';
                backBtn.className = 'custom-formula-btn custom-formula-btn-secondary';
                backBtn.textContent = 'â† Back';
                headerFlex.appendChild(backBtn);

                const deleteCategoryBtn = document.createElement('button');
                deleteCategoryBtn.dataset.action = 'delete-category';
                deleteCategoryBtn.dataset.category = category;
                deleteCategoryBtn.className = 'custom-formula-btn custom-formula-btn-secondary';
                deleteCategoryBtn.style.flexGrow = '1';
                deleteCategoryBtn.textContent = 'Delete Category';
                headerFlex.appendChild(deleteCategoryBtn);

                const categoryHeading = document.createElement('h2');
                categoryHeading.className = 'custom-formula-view-header';
                categoryHeading.style.textAlign = 'center';
                categoryHeading.style.margin = '0';
                categoryHeading.textContent = category;

                headerCard.appendChild(headerFlex);
                headerCard.appendChild(categoryHeading);
                fragment.appendChild(headerCard);

                if (typeof categoryData !== 'object' || categoryData === null) {
                    const errorCard = document.createElement('div');
                    errorCard.className = 'custom-formula-card';
                    const errorP = document.createElement('p');
                    errorP.textContent = 'Error: Category data is corrupted.';
                    errorCard.appendChild(errorP);
                    fragment.appendChild(errorCard);
                } else {
                    const subcategories = Object.keys(categoryData);
                    if (subcategories.length === 0) {
                        const emptyCard = document.createElement('div');
                        emptyCard.className = 'custom-formula-card';
                        const emptyP = document.createElement('p');
                        emptyP.textContent = 'This category is empty.';
                        emptyCard.appendChild(emptyP);
                        fragment.appendChild(emptyCard);
                    } else {
                        subcategories.forEach(subcategory => {
                            const items = categoryData[subcategory];
                            if (!Array.isArray(items)) {
                                return; // Skip corrupted data
                            }

                            const details = document.createElement('details');
                            details.className = 'custom-formula-subcategory-item custom-formula-card';

                            const summary = document.createElement('summary');
                            summary.appendChild(document.createTextNode(subcategory));

                            const viewActions = document.createElement('div');
                            viewActions.className = 'custom-formula-view-actions';

                            const askAiBtn = document.createElement('button');
                            askAiBtn.dataset.action = 'ask-ai';
                            askAiBtn.dataset.category = category;
                            askAiBtn.dataset.subcategory = subcategory;
                            askAiBtn.className = 'custom-formula-btn custom-formula-btn-small custom-formula-btn-ask-ai';
                            askAiBtn.textContent = 'âœ¨';
                            viewActions.appendChild(askAiBtn);

                            const editBtn = document.createElement('button');
                            editBtn.dataset.action = 'edit-subcategory';
                            editBtn.dataset.category = category;
                            editBtn.dataset.subcategory = subcategory;
                            editBtn.className = 'custom-formula-btn custom-formula-btn-small';
                            editBtn.textContent = 'âœï¸';
                            viewActions.appendChild(editBtn);

                            const deleteBtn = document.createElement('button');
                            deleteBtn.dataset.action = 'delete-subcategory';
                            deleteBtn.dataset.category = category;
                            deleteBtn.dataset.subcategory = subcategory;
                            deleteBtn.className = 'custom-formula-btn custom-formula-btn-secondary custom-formula-btn-small';
                            deleteBtn.textContent = 'ðŸ—‘ï¸';
                            viewActions.appendChild(deleteBtn);

                            summary.appendChild(viewActions);
                            details.appendChild(summary);

                            const ul = document.createElement('ul');
                            items.forEach(item => {
                                const li = document.createElement('li');
                                li.className = 'custom-formula-formula-item with-border' + (item.completed ? ' custom-formula-completed' : '');

                                const span = document.createElement('span');
                                span.className = 'custom-formula-formula-text';
                                renderTextWithMath(span, item.text);
                                li.appendChild(span);

                                if (item.subgoals && item.subgoals.length > 0) {
                                    const subUl = document.createElement('ul');
                                    subUl.className = 'custom-formula-subgoal-list';
                                    item.subgoals.forEach(subgoal => {
                                        const subLi = document.createElement('li');
                                        subLi.className = 'custom-formula-formula-item custom-formula-subgoal-item' + (subgoal.completed ? ' custom-formula-completed' : '');

                                        const subSpan = document.createElement('span');
                                        subSpan.className = 'custom-formula-formula-text';
                                        renderTextWithMath(subSpan, subgoal.text);
                                        subLi.appendChild(subSpan);
                                        subUl.appendChild(subLi);
                                    });
                                    li.appendChild(subUl);
                                }
                                ul.appendChild(li);
                            });
                            details.appendChild(ul);
                            fragment.appendChild(details);
                        });
                    }
                }

                savedDataView.appendChild(fragment);
                ensureMathJax().then(() => MathJax.typesetPromise());
            }

            async function runUncompletedSession(category, subcategory) {
              const savedData = await idbHelper.get('savedFormulaData') || {};
              const sessionData = savedData["Uncompleted Sessions"]?.[category]?.[subcategory];

              if (sessionData && sessionData.formulas) {
                // Load the session
                sessionCategory = category;
                sessionSubcategory = subcategory;
                formulas = sessionData.formulas.map(f => {
                    if (f && typeof f === 'object' && f.id && Array.isArray(f.subgoals)) {
                      return f;
                    }
                    return createGoal(f.text || '');
                  }).filter(f => f.text);
                saveFormulasToLocalStorage(); // <-- Add this line

                // If the session stored a duration, restore it and auto-start
                if (sessionData.duration && Number.isFinite(sessionData.duration) && sessionData.duration > 0) {
                  timerState.duration = sessionData.duration;
                  timerState.remaining = sessionData.duration;
                  timerState.status = 'stopped';
                  saveTimerState();
                  // Auto-start the timer so the "process restarts"
                  startTimer();
                }

                // Remove the entry from "Uncompleted Sessions"
                delete savedData["Uncompleted Sessions"][category][subcategory];
                if (Object.keys(savedData["Uncompleted Sessions"][category]).length === 0) {
                  delete savedData["Uncompleted Sessions"][category];
                }
                if (Object.keys(savedData["Uncompleted Sessions"]).length === 0) {
                  delete savedData["Uncompleted Sessions"];
                }
                await saveAllFormulaData(savedData);

                // Start the UI
                renderFormulas();
                renderSessionHeader();
                hideAllViews();
              }
            }

            async function runFailedSession(category, subcategory) {
              const savedData = await idbHelper.get('savedFormulaData') || {};
              const sessionData = savedData["Failed Sessions"]?.[category]?.[subcategory];

              if (sessionData && sessionData.formulas) {
                // Load the session
                sessionCategory = category;
                sessionSubcategory = subcategory;
                 formulas = sessionData.formulas.map(f => {
                    if (f && typeof f === 'object' && f.id && Array.isArray(f.subgoals)) {
                      return f;
                    }
                    return createGoal(f.text || '');
                  }).filter(f => f.text);
                saveFormulasToLocalStorage(); // <-- Add this line

                // Restore duration (Failed Sessions already save duration on timer finish)
                if (sessionData.duration && Number.isFinite(sessionData.duration) && sessionData.duration > 0) {
                  timerState.duration = sessionData.duration;
                  timerState.remaining = sessionData.duration;
                  timerState.status = 'stopped';
                  saveTimerState();
                  // Auto-start the timer so the user immediately restarts the work
                  startTimer();
                }

                // Remove the entry from "Failed Sessions"
                delete savedData["Failed Sessions"][category][subcategory];
                if (Object.keys(savedData["Failed Sessions"][category]).length === 0) {
                  delete savedData["Failed Sessions"][category];
                }
                if (Object.keys(savedData["Failed Sessions"]).length === 0) {
                  delete savedData["Failed Sessions"];
                }
                await saveAllFormulaData(savedData);

                // Start the UI
                renderFormulas();
                renderSessionHeader();
                hideAllViews();
              }
            }

            async function deleteUncompletedSession(category, subcategory) {
                const confirmed = await showConfirmation('Delete Uncompleted Session', `Are you sure you want to delete the uncompleted session for "${subcategory}"?`);
                if (!confirmed) return;
                const savedData = await idbHelper.get('savedFormulaData') || {};
                if (savedData["Uncompleted Sessions"]?.[category]?.[subcategory]) {
                    delete savedData["Uncompleted Sessions"][category][subcategory];
                    if (Object.keys(savedData["Uncompleted Sessions"][category]).length === 0) {
                        delete savedData["Uncompleted Sessions"][category];
                    }
                    if (Object.keys(savedData["Uncompleted Sessions"]).length === 0) {
                        delete savedData["Uncompleted Sessions"];
                    }
                    await saveAllFormulaData(savedData);
                    await showUncompletedDataView(); // Re-render the view
                }
            }

            async function deleteFailedSession(category, subcategory) {
                const confirmed = await showConfirmation('Delete Failed Session', `Are you sure you want to delete the session for "${subcategory}"?`);
                if (!confirmed) return;
                const savedData = await idbHelper.get('savedFormulaData') || {};
                if (savedData["Failed Sessions"]?.[category]?.[subcategory]) {
                    delete savedData["Failed Sessions"][category][subcategory];
                    if (Object.keys(savedData["Failed Sessions"][category]).length === 0) {
                        delete savedData["Failed Sessions"][category];
                    }
                     if (Object.keys(savedData["Failed Sessions"]).length === 0) {
                        delete savedData["Failed Sessions"];
                    }
                    await saveAllFormulaData(savedData);
                    await showFailedDataView(); // Re-render the view
                }
            }

            async function deleteSavedSubcategory(category, subcategory) {
                const confirmed = await showConfirmation('Delete Subcategory', `Are you sure you want to delete the subcategory "${subcategory}"? This action cannot be undone.`);
                if (!confirmed) return;

                const savedData = await idbHelper.get('savedFormulaData') || {};
                if (savedData[category] && savedData[category][subcategory]) {
                    delete savedData[category][subcategory];
                    if (Object.keys(savedData[category]).length === 0) {
                        delete savedData[category];
                    }
                    await saveAllFormulaData(savedData);

                    if (!savedData[category]) {
                        savedDataView.style.display = 'none';
                        savedDataView.innerHTML = '';
                        mainContainer.style.display = 'block';
                        await renderSavedCategories();
                    } else {
                        await showSavedDataView(category);
                    }
                }
            }

            async function deleteSavedCategory(category) {
                const confirmed = await showConfirmation('Delete Category', `Are you sure you want to delete the entire category "${category}"? This will delete all its subcategories and cannot be undone.`);
                if (!confirmed) return;
                const savedData = await idbHelper.get('savedFormulaData') || {};
                if (savedData[category]) {
                    delete savedData[category];
                    await saveAllFormulaData(savedData);
                    savedDataView.style.display = 'none';
                    savedDataView.innerHTML = '';
                    mainContainer.style.display = 'block';
                    await renderSavedCategories();
                }
            }

            async function editSavedSubcategory(category, subcategory) {
                const savedData = await idbHelper.get('savedFormulaData') || {};
                const subcategoryData = savedData[category]?.[subcategory];

                if (subcategoryData) {
                    sessionCategory = category;
                    sessionSubcategory = subcategory;
                    formulas = JSON.parse(JSON.stringify(subcategoryData)); // Deep copy
                    isEditing = true; // Set editing flag
                    saveFormulasToLocalStorage();
                    renderFormulas();
                    renderSessionHeader();
                    showView('main');
                } else {
                    showNotification('Error', 'Could not find the selected subcategory to edit.');
                }
            }

            function bindGoalEvents(goalWrapper, formula, textElement) {
                goalWrapper.addEventListener('mousedown', e => {
                    if (e.target.type === 'checkbox') return;
                    if (e.target.closest('.custom-formula-subgoal-item')) return;
                    isLongPress = false;
                    startX = e.clientX;
                    startY = e.clientY;
                    longPressTimer = setTimeout(() => {
                        isLongPress = true;
                        openSubgoalModal(formula.id);
                    }, 500);
                });

                goalWrapper.addEventListener('mousemove', e => {
                    if (longPressTimer) {
                        const dx = Math.abs(e.clientX - startX);
                        const dy = Math.abs(e.clientY - startY);
                        if (dx > 5 || dy > 5) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                    }
                });

                goalWrapper.addEventListener('mouseup', () => {
                    clearTimeout(longPressTimer);
                });

                goalWrapper.addEventListener('mouseleave', () => {
                    clearTimeout(longPressTimer);
                });

                goalWrapper.addEventListener('touchstart', e => {
                    if (e.target.type === 'checkbox') return;
                    if (e.target.closest('.custom-formula-subgoal-item')) return;
                    isLongPress = false;
                    const t = e.touches[0];
                    startX = t.clientX;
                    startY = t.clientY;
                    longPressTimer = setTimeout(() => {
                        isLongPress = true;
                        openSubgoalModal(formula.id);
                    }, 500);
                });

                goalWrapper.addEventListener('touchmove', e => {
                    if (longPressTimer) {
                        const t = e.touches[0];
                        const dx = Math.abs(t.clientX - startX);
                        const dy = Math.abs(t.clientY - startY);
                        if (dx > 5 || dy > 5) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                    }
                });

                goalWrapper.addEventListener('touchend', () => {
                    clearTimeout(longPressTimer);
                });

                textElement.addEventListener('click', (e) => {
                    if (isLongPress) {
                        e.preventDefault();
                        isLongPress = false;
                        return;
                    }
                    const subgoalsContainer = goalWrapper.querySelector('.custom-formula-subgoal-list');
                    if (subgoalsContainer) {
                        subgoalsContainer.classList.toggle('d-none');
                        goalWrapper.classList.toggle('collapsed');
                    }
                });
            }

            function enableDrag(li, checkbox, id, parentId, type) {
                // Ensure ID is set for persistence logic
                if (!li.dataset.id) {
                    li.dataset.id = id;
                }

                let dragTimer;
                let isDragging = false;
                let startY = 0;
                let startX = 0;
                let currentClientY = 0;
                let currentClientX = 0;
                let lastReorderY = 0; // Tracks Y-position for throttled reordering
                let parentUl = null;
                let placeholder = null;
                let rAF = null;

                const cleanup = () => {
                    clearTimeout(dragTimer);
                    if (rAF) {
                        cancelAnimationFrame(rAF);
                        rAF = null;
                    }

                    if (isDragging) {
                        isDragging = false;
                        li.classList.remove('custom-formula-dragging');
                        li.style.position = '';
                        li.style.top = '';
                        li.style.width = '';
                        li.style.height = '';
                        li.style.zIndex = '';
                        li.style.left = '';

                        // Restore document and element styles
                        document.documentElement.style.overflow = '';
                        document.body.style.touchAction = '';
                        li.style.touchAction = '';

                        if (placeholder && placeholder.parentNode) {
                            placeholder.parentNode.replaceChild(li, placeholder);
                        }
                        placeholder = null;

                        document.body.style.userSelect = '';
                        document.body.style.webkitUserSelect = '';

                        // Save the new order
                        const newOrderIds = Array.from(parentUl.children).map(el => el.dataset.id).filter(Boolean);

                        if (type === 'goal') {
                             const newFormulas = [];
                             newOrderIds.forEach(lid => {
                                 const f = formulas.find(x => x.id === lid);
                                 if (f) newFormulas.push(f);
                             });
                             if (newFormulas.length === formulas.length) {
                                 formulas = newFormulas;
                                 saveFormulasToLocalStorage();
                             }
                        } else if (type === 'subgoal') {
                            const parentGoal = formulas.find(f => f.id === parentId);

                            if (parentGoal) {
                                const newSubgoals = [];
                                newOrderIds.forEach(sid => {
                                    const sg = parentGoal.subgoals.find(x => x.id === sid);
                                    if(sg) newSubgoals.push(sg);
                                });

                                // Only update if order changed
                                if (newSubgoals.length === parentGoal.subgoals.length) { // Basic sanity check
                                    parentGoal.subgoals = newSubgoals;
                                    saveFormulasToLocalStorage();
                                }
                            }
                        }
                    }

                    window.removeEventListener('mousemove', onPointerMove);
                    window.removeEventListener('touchmove', onPointerMove);
                    window.removeEventListener('mouseup', onPointerUp);
                    window.removeEventListener('touchend', onPointerUp);
                    window.removeEventListener('touchcancel', onPointerUp);
                };

                const updateDrag = () => {
                    if (!isDragging) return;

                    // Move element
                    const currentTop = parseFloat(li.style.top) || 0;
                    const dy = currentClientY - startY;
                    li.style.top = (currentTop + dy) + 'px';
                    startY = currentClientY; // Update for next frame logic

                    // Auto-scroll logic
                    const SCROLL_ZONE = 50;
                    const MAX_SCROLL_SPEED = 10;
                    const viewportHeight = window.innerHeight;

                    if (currentClientY < SCROLL_ZONE) {
                        window.scrollBy(0, -MAX_SCROLL_SPEED * (1 - currentClientY / SCROLL_ZONE));
                    } else if (currentClientY > viewportHeight - SCROLL_ZONE) {
                        window.scrollBy(0, MAX_SCROLL_SPEED * (1 - (viewportHeight - currentClientY) / SCROLL_ZONE));
                    }

                    // Constrain horizontal bounds to avoid glitchy swapping
                    const parentRect = parentUl.getBoundingClientRect();
                    const HORIZONTAL_BUFFER = 50;
                    if (currentClientX < parentRect.left - HORIZONTAL_BUFFER || currentClientX > parentRect.right + HORIZONTAL_BUFFER) {
                        rAF = requestAnimationFrame(updateDrag);
                        return;
                    }

                    // Hit testing - Throttled: only check if moved > 6px
                    if (Math.abs(currentClientY - lastReorderY) > 6) {
                        lastReorderY = currentClientY;

                        const siblings = Array.from(parentUl.children).filter(child =>
                            child !== placeholder
                        );

                        const draggedRect = li.getBoundingClientRect();
                        const draggedCenter = draggedRect.top + draggedRect.height / 2;

                        for (const sibling of siblings) {
                            const siblingRect = sibling.getBoundingClientRect();
                            const siblingCenter = siblingRect.top + siblingRect.height / 2;

                            if (draggedCenter < siblingCenter && sibling.previousElementSibling !== placeholder) {
                                parentUl.insertBefore(placeholder, sibling);
                                break;
                            } else if (draggedCenter > siblingCenter && sibling.nextElementSibling !== placeholder) {
                                parentUl.insertBefore(placeholder, sibling.nextElementSibling);
                            }
                        }
                    }

                    rAF = requestAnimationFrame(updateDrag);
                };

                const onPointerDown = (e) => {
                    // Only left click or touch
                    if (e.type === 'mousedown' && e.button !== 0) return;

                    startY = e.touches ? e.touches[0].clientY : e.clientY;
                    startX = e.touches ? e.touches[0].clientX : e.clientX;
                    parentUl = li.parentElement;
                    // console.log('PointerDown', startX, startY);

                    dragTimer = setTimeout(() => {
                        // console.log('DragTimer fired');
                        isDragging = true;

                        // Lock scrolling and touch actions
                        document.documentElement.style.overflow = "hidden";
                        document.body.style.touchAction = "none";
                        li.style.touchAction = "none";

                        // Visual feedback
                        if (navigator.vibrate) navigator.vibrate(50);

                        // Setup placeholder
                        const rect = li.getBoundingClientRect();
                        placeholder = document.createElement('li');
                        placeholder.className = 'custom-formula-formula-item custom-formula-subgoal-item custom-formula-drag-placeholder';
                        placeholder.style.height = rect.height + 'px';

                        // Setup dragged element
                        li.style.width = rect.width + 'px';
                        li.style.height = rect.height + 'px';
                        li.style.position = 'fixed';
                        li.style.zIndex = '1000';
                        li.style.top = rect.top + 'px';
                        li.style.left = rect.left + 'px';
                        li.classList.add('custom-formula-dragging');

                        currentClientY = startY;
                        lastReorderY = startY; // Initialize for throttling

                        parentUl.insertBefore(placeholder, li);
                        document.body.appendChild(li); // Move to body

                        document.body.style.userSelect = 'none';
                        document.body.style.webkitUserSelect = 'none';

                        // Attach global move/up listeners only when drag starts
                        window.addEventListener('mousemove', onPointerMove, { passive: false });
                        window.addEventListener('touchmove', onPointerMove, { passive: false });
                        window.addEventListener('mouseup', onPointerUp);
                        window.addEventListener('touchend', onPointerUp);
                        window.addEventListener('touchcancel', onPointerUp);

                        // Start loop
                        rAF = requestAnimationFrame(updateDrag);

                    }, 300); // 300ms long press

                    // Attach global up listeners to cancel timer if released early
                    window.addEventListener('mouseup', onPointerUp);
                    window.addEventListener('touchend', onPointerUp);
                    window.addEventListener('touchcancel', onPointerUp);
                };

                const onPointerMove = (e) => {
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;

                    if (!isDragging) {
                        // Check if we need to cancel timer due to movement
                        // We check both X and Y to detect scrolling (vertical or horizontal)
                        if (dragTimer && (Math.abs(clientY - startY) > 10 || Math.abs(clientX - startX) > 10)) {
                             // console.log('Cancelling drag timer due to movement', Math.abs(clientY - startY), Math.abs(clientX - startX));
                             clearTimeout(dragTimer);
                        }
                        return;
                    }

                    if (e.cancelable) e.preventDefault();

                    currentClientY = clientY;
                    currentClientX = clientX;
                };

                const onPointerUp = (e) => {
                    clearTimeout(dragTimer);

                    // cleanup global listeners if they were added just for timer cancellation
                    if (!isDragging) {
                        window.removeEventListener('mouseup', onPointerUp);
                        window.removeEventListener('touchend', onPointerUp);
                        window.removeEventListener('touchcancel', onPointerUp);
                    }

                    if (isDragging) {
                        cleanup();
                        // Prevent click event on checkbox
                        const captureClick = (ev) => {
                            ev.stopPropagation();
                            ev.preventDefault();
                            checkbox.removeEventListener('click', captureClick, true);
                        };
                        checkbox.addEventListener('click', captureClick, true);
                    }
                };

                // Attach listeners to checkbox
                checkbox.addEventListener('mousedown', onPointerDown);
                checkbox.addEventListener('touchstart', onPointerDown, { passive: false });

                // Listen for moves on the checkbox itself to cancel timer if needed (especially for touch scrolling)
                checkbox.addEventListener('touchmove', onPointerMove, { passive: false });
            }

            function renderFormulas() {
                formulaList.innerHTML = '';
                if (formulas.length === 0) {
                    updateProgress();
                    return;
                }

                formulas.forEach((formula, index) => {
                    const li = document.createElement('li');
                    li.className = 'custom-formula-formula-item';
                    if (formula.completed) {
                        li.classList.add('custom-formula-completed');
                    }
                    li.dataset.id = formula.id;

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `custom-formula-formula-${formula.id}`;
                    checkbox.checked = formula.completed;
                    checkbox.addEventListener('change', handleCheckboxChange);

                    const goalContent = document.createElement('div');
                    goalContent.className = 'custom-formula-goal-content';

                    const text = document.createElement('span');
                    text.className = 'custom-formula-formula-text';
                    renderTextWithMath(text, formula.text);

                    goalContent.appendChild(checkbox);
                    goalContent.appendChild(text);

                    li.appendChild(goalContent);

                    bindGoalEvents(li, formula, text);

                    // Enable drag for parent goal
                    enableDrag(li, checkbox, formula.id, null, 'goal');

                    if (formula.subgoals && formula.subgoals.length > 0) {
                        li.classList.add('has-subgoals', 'collapsed');
                        const dot = document.createElement('div');
                        dot.className = 'expandable-dot';
                        goalContent.appendChild(dot);

                        const subgoalsContainer = document.createElement('ul');
                        subgoalsContainer.className = 'custom-formula-subgoal-list d-none';
                        formula.subgoals.forEach(subgoal => {
                            const subgoalLi = document.createElement('li');
                            subgoalLi.className = 'custom-formula-formula-item custom-formula-subgoal-item';
                            if (subgoal.completed) {
                                subgoalLi.classList.add('custom-formula-completed');
                            }
                            subgoalLi.dataset.id = subgoal.id;
                            subgoalLi.dataset.parentId = formula.id;

                            // Enable drag for subgoals - passing the li itself as the handle
                            enableDrag(subgoalLi, subgoalLi, subgoal.id, formula.id, 'subgoal');

                            const subgoalLabel = document.createElement('span'); // Changed to span as no checkbox to label
                            subgoalLabel.className = 'custom-formula-formula-text';
                            renderTextWithMath(subgoalLabel, subgoal.text);

                            subgoalLi.appendChild(subgoalLabel);
                            subgoalsContainer.appendChild(subgoalLi);
                        });
                        li.appendChild(subgoalsContainer);
                    }

                    formulaList.appendChild(li);
                });

                // Let MathJax process the new formulas
                ensureMathJax().then(() => MathJax.typesetPromise());
                updateProgress();
            }

            function handleCheckboxChange(e) {
                const li = e.target.closest('.custom-formula-formula-item');
                const id = li.dataset.id;
                const isChecked = e.target.checked;

                let item;
                if (li.classList.contains('custom-formula-subgoal-item')) {
                    const parentId = li.dataset.parentId;
                    const parentFormula = formulas.find(f => f.id === parentId);
                    if (parentFormula) {
                        item = parentFormula.subgoals.find(sg => sg.id === id);
                    }
                } else {
                    item = formulas.find(f => f.id === id);
                }

                if (!item) return;

                item.completed = isChecked;

                if (isChecked) {
                    li.classList.add('custom-formula-completed');
                    showCelebration();
                } else {
                    li.classList.remove('custom-formula-completed');
                }
                updateProgress();
                saveFormulasToLocalStorage();
            }

            function updateProgress() {
                const checkedCount = formulas.filter(f => f.completed).length;
                const totalCount = formulas.length;

                if (totalCount === 0) {
                    progressBar.style.width = '0%';
                    progressText.textContent = '0% Completed';
                    return;
                }

                const percentage = Math.round((checkedCount / totalCount) * 100);
                progressBar.style.width = `${percentage}%`;
                progressText.textContent = `${percentage}% Completed (${checkedCount}/${totalCount})`;
            }

            // --- Modals & Sidebar ---

            function showNotification(title, message) {
                notificationTitle.textContent = title;
                notificationMessage.textContent = message;
                notificationModal.classList.add('custom-formula-show');
            }

            notificationCloseBtn.addEventListener('click', () => {
                notificationModal.classList.remove('custom-formula-show');
            });
            notificationModal.addEventListener('click', (e) => {
                // Don't close if loading
                if (e.target === notificationModal && !notificationModal.classList.contains('custom-formula-loading')) {
                    notificationModal.classList.remove('custom-formula-show');
                }
            });

            function showLoading(message) {
                notificationTitle.textContent = 'Please Wait';
                notificationMessage.textContent = message;
                notificationModal.classList.add('custom-formula-show', 'custom-formula-loading');
            }

            function hideLoading() {
                notificationModal.classList.remove('custom-formula-show', 'custom-formula-loading');
            }

            function showConfirmation(title, message, confirmText = 'Confirm', cancelText = 'Cancel') {
                return new Promise((resolve) => {
                    confirmationTitle.textContent = title;
                    confirmationMessage.textContent = message;
                    confirmationConfirmBtn.textContent = confirmText;
                    confirmationCancelBtn.textContent = cancelText;
                    confirmationModal.classList.add('custom-formula-show');

                    const cleanup = (result) => {
                        confirmationModal.classList.remove('custom-formula-show');
                        confirmationConfirmBtn.removeEventListener('click', confirmHandler);
                        confirmationCancelBtn.removeEventListener('click', cancelHandler);
                        resolve(result);
                    };

                    const confirmHandler = () => cleanup(true);
                    const cancelHandler = () => cleanup(false);

                    confirmationConfirmBtn.addEventListener('click', confirmHandler, { once: true });
                    confirmationCancelBtn.addEventListener('click', cancelHandler, { once: true });
                });
            }

            function showCelebration() {
                celebrationModal.classList.add('custom-formula-show');
                setTimeout(() => {
                    celebrationModal.classList.remove('custom-formula-show');
                }, 2000);
            }

            celebrationModal.addEventListener('click', () => {
                celebrationModal.classList.remove('custom-formula-show');
            });

            saveProgressBtn.addEventListener('click', async () => {
                if (timerState.status === 'running') {
                    showNotification('Action Unavailable', 'You cannot save progress while the timer is running. Please pause or reset the timer first.');
                    return;
                }

                if (!sessionCategory || !sessionSubcategory || formulas.length === 0) {
                    showNotification('Notice', 'There is no active session to save.');
                    return;
                }

                const savedData = await idbHelper.get('savedFormulaData') || {};

                if (isEditing) {
                    // Overwrite the existing session
                    if (!savedData[sessionCategory]) savedData[sessionCategory] = {};
                    savedData[sessionCategory][sessionSubcategory] = JSON.parse(JSON.stringify(formulas));
                } else {
                    let changesMade = false;
                    const completedFormulas = formulas.filter(f => f.completed);
                    const uncompletedFormulas = formulas.filter(f => !f.completed);

                    // 1. Handle completed formulas
                    if (completedFormulas.length > 0) {
                        if (!savedData[sessionCategory]) savedData[sessionCategory] = {};
                        if (!savedData[sessionCategory][sessionSubcategory]) savedData[sessionCategory][sessionSubcategory] = [];

                        completedFormulas.forEach(formula => {
                            const existing = savedData[sessionCategory][sessionSubcategory].find(f => f.text === formula.text);
                            if (existing) {
                                if (!existing.completed) existing.completed = true;
                            } else {
                                savedData[sessionCategory][sessionSubcategory].push(JSON.parse(JSON.stringify(formula)));
                            }
                        });
                        changesMade = true;
                    }

                    // 2. Handle uncompleted formulas
                    if (uncompletedFormulas.length > 0) {
                        if (!savedData["Uncompleted Sessions"]) savedData["Uncompleted Sessions"] = {};
                        if (!savedData["Uncompleted Sessions"][sessionCategory]) savedData["Uncompleted Sessions"][sessionCategory] = {};
                        if (!savedData["Uncompleted Sessions"][sessionCategory][sessionSubcategory]) {
                            savedData["Uncompleted Sessions"][sessionCategory][sessionSubcategory] = { formulas: [] };
                        }

                        const existingUncompleted = savedData["Uncompleted Sessions"][sessionCategory][sessionSubcategory].formulas;
                        const existingTexts = new Set(existingUncompleted.map(f => f.text));

                        uncompletedFormulas.forEach(formula => {
                            if (!existingTexts.has(formula.text)) {
                                existingUncompleted.push(JSON.parse(JSON.stringify(formula)));
                                changesMade = true;
                            }
                        });
                    }

                    if (!changesMade) {
                        showNotification('Notice', 'No changes to save.');
                        return;
                    }
                }

                // 3. Persist all changes to the database
                await saveAllFormulaData(savedData);

                // 4. Clear the main session UI and local storage
                formulas = [];
                sessionCategory = '';
                sessionSubcategory = '';
                isEditing = false; // Reset editing flag
                // Clear the persisted session from localStorage so it doesn't reload
                const ls = getSafeLocalStorage();
                if(ls) {
                    ls.removeItem('custom-formula-formulas');
                    ls.removeItem('custom-formula-sessionCategory');
                    ls.removeItem('custom-formula-sessionSubcategory');
                }

                // 5. Update UI
                renderFormulas(); // This will clear the list
                renderSessionHeader(); // This will hide the header
                await renderSavedCategories(); // This will update the sidebar

                showNotification('Success', isEditing ? 'Session updated successfully.' : 'Progress saved. Unchecked items were moved to "Uncompleted Sessions".');
            });

            document.getElementById('custom-formula-cancel-save-btn').addEventListener('click', () => {
                saveModal.classList.remove('custom-formula-show');
            });

            saveModalBtn.addEventListener('click', () => {
                const category = categoryInput.value.trim();
                const subcategory = subcategoryInput.value.trim();

                if (!category || !subcategory) {
                    showNotification('Input Required', 'Please fill out both category and sub-category fields.');
                    return;
                }

                // This modal is for setting up the session
                sessionCategory = category;
                sessionSubcategory = subcategory;

                // Filter for duplicates before adding
                const existingFormulas = new Set(formulas.map(f => f.text));
                const uniqueNewFormulas = parsedFormulas.filter(f => !existingFormulas.has(f.text));

                if(uniqueNewFormulas.length === 0 && parsedFormulas.length > 0) {
                    showNotification('Notice', "All goals from the upload already exist in the current session.");
                    parsedFormulas = [];
                    return;
                }

                formulas.push(...uniqueNewFormulas);
                parsedFormulas = [];
                manualFormulaInput.value = ''; // Also clear manual input in case it was used

                saveFormulasToLocalStorage();
                renderFormulas();
                renderSessionHeader(); // Display the new header

                // Clear inputs and hide modal
                categoryInput.value = '';
                subcategoryInput.value = '';
                saveModal.classList.remove('custom-formula-show');
            });

            sandwichBtn.addEventListener('click', () => {
                const isExpanded = sandwichBtn.getAttribute('aria-expanded') === 'true';
                sandwichBtn.setAttribute('aria-expanded', String(!isExpanded));
                document.body.classList.toggle('custom-formula-sidebar-open');
            });

            document.addEventListener('click', (e) => {
                const sidebar = document.getElementById('custom-formula-sidebar');
                const isSidebarOpen = document.body.classList.contains('custom-formula-sidebar-open');

                // Close sidebar if click is outside of it and not on the sandwich button
                if (isSidebarOpen && !sidebar.contains(e.target) && !sandwichBtn.contains(e.target)) {
                    document.body.classList.remove('custom-formula-sidebar-open');
                    sandwichBtn.setAttribute('aria-expanded', 'false');
                }
            });

            savedCategoriesList.addEventListener('click', async (e) => {
                if (e.target.tagName === 'BUTTON' && e.target.dataset.category) {
                    await showSavedDataView(e.target.dataset.category);
                }
            });

            showUncompletedBtn.addEventListener('click', async () => {
                await showUncompletedDataView();
            });

            showFailedBtn.addEventListener('click', async () => {
                await showFailedDataView();
            });

            async function showFailedDataView() {
                const savedData = await idbHelper.get('savedFormulaData') || {};
                const failedSessions = savedData["Failed Sessions"] || {};
                failedDataView.innerHTML = ''; // Clear existing content

                const fragment = document.createDocumentFragment();

                const headerCard = document.createElement('div');
                headerCard.className = 'custom-formula-card';

                const backBtn = document.createElement('button');
                backBtn.dataset.action = 'back-to-main';
                backBtn.className = 'custom-formula-btn custom-formula-btn-secondary';
                backBtn.textContent = 'â† Back to Main';
                headerCard.appendChild(backBtn);

                const header = document.createElement('h2');
                header.className = 'custom-formula-view-header';
                header.textContent = 'Failed Sessions';
                headerCard.appendChild(header);

                fragment.appendChild(headerCard);

                const failedCategories = Object.keys(failedSessions);
                if (failedCategories.length === 0) {
                    const emptyCard = document.createElement('div');
                    emptyCard.className = 'custom-formula-card';
                    const p = document.createElement('p');
                    p.className = 'text-center';
                    p.textContent = 'No failed sessions found.';
                    emptyCard.appendChild(p);
                    fragment.appendChild(emptyCard);
                } else {
                    failedCategories.forEach(category => {
                        const subcategories = failedSessions[category];
                        const categoryCard = document.createElement('div');
                        categoryCard.className = 'custom-formula-card';

                        const categoryHeader = document.createElement('div');
                        categoryHeader.className = 'custom-formula-category-header';

                        const h3 = document.createElement('h3');
                        h3.textContent = category;
                        categoryHeader.appendChild(h3);

                        const deleteCategoryBtn = document.createElement('button');
                        deleteCategoryBtn.dataset.action = 'delete-view-category';
                        deleteCategoryBtn.dataset.viewType = 'failed';
                        deleteCategoryBtn.dataset.category = category;
                        deleteCategoryBtn.className = 'custom-formula-btn custom-formula-btn-secondary';
                        deleteCategoryBtn.textContent = 'Delete Category';
                        categoryHeader.appendChild(deleteCategoryBtn);

                        categoryCard.appendChild(categoryHeader);

                        Object.keys(subcategories).forEach(subcategory => {
                            const sessionData = subcategories[subcategory];
                            const items = sessionData.formulas || [];
                            const durationMs = sessionData.duration || 0;
                            const minutes = Math.floor(durationMs / 60000);
                            const seconds = Math.floor((durationMs % 60000) / 1000);
                            const timerString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                            const details = document.createElement('details');
                            details.className = 'custom-formula-subcategory-item';

                            const summary = document.createElement('summary');
                            summary.appendChild(document.createTextNode(`${subcategory} (Timer: ${timerString})`));

                            const viewActions = document.createElement('div');
                            viewActions.className = 'custom-formula-view-actions';

                            const runBtn = document.createElement('button');
                            runBtn.dataset.action = 'run-failed';
                            runBtn.dataset.category = category;
                            runBtn.dataset.subcategory = subcategory;
                            runBtn.className = 'custom-formula-btn custom-formula-btn-small';
                            runBtn.textContent = 'Run';
                            viewActions.appendChild(runBtn);

                            const deleteBtn = document.createElement('button');
                            deleteBtn.dataset.action = 'delete-failed';
                            deleteBtn.dataset.category = category;
                            deleteBtn.dataset.subcategory = subcategory;
                            deleteBtn.className = 'custom-formula-btn custom-formula-btn-secondary custom-formula-btn-small';
                            deleteBtn.textContent = 'Delete';
                            viewActions.appendChild(deleteBtn);

                            summary.appendChild(viewActions);
                            details.appendChild(summary);

                            const ul = document.createElement('ul');
                            items.forEach(item => {
                                const li = document.createElement('li');
                                li.className = 'custom-formula-formula-item with-border';

                                const span = document.createElement('span');
                                span.className = 'custom-formula-formula-text';
                                renderTextWithMath(span, item.text);
                                li.appendChild(span);

                                if (item.subgoals && item.subgoals.length > 0) {
                                    const subUl = document.createElement('ul');
                                    subUl.className = 'custom-formula-subgoal-list';
                                    item.subgoals.forEach(subgoal => {
                                        const subLi = document.createElement('li');
                                        subLi.className = 'custom-formula-formula-item custom-formula-subgoal-item';

                                        const subSpan = document.createElement('span');
                                        subSpan.className = 'custom-formula-formula-text';
                                        renderTextWithMath(subSpan, subgoal.text);
                                        subLi.appendChild(subSpan);
                                        subUl.appendChild(subLi);
                                    });
                                    li.appendChild(subUl);
                                }
                                ul.appendChild(li);
                            });
                            details.appendChild(ul);
                            categoryCard.appendChild(details);
                        });
                        fragment.appendChild(categoryCard);
                    });
                }
                failedDataView.appendChild(fragment);
                showView('failed');
                ensureMathJax().then(() => MathJax.typesetPromise([failedDataView]));
            }

            async function showUncompletedDataView() {
                const savedData = await idbHelper.get('savedFormulaData') || {};
                const uncompletedSessions = savedData["Uncompleted Sessions"] || {};
                uncompletedDataView.innerHTML = ''; // Clear existing content

                const fragment = document.createDocumentFragment();

                const headerCard = document.createElement('div');
                headerCard.className = 'custom-formula-card';

                const backBtn = document.createElement('button');
                backBtn.dataset.action = 'back-to-main';
                backBtn.className = 'custom-formula-btn custom-formula-btn-secondary';
                backBtn.textContent = 'â† Back to Main';
                headerCard.appendChild(backBtn);

                const header = document.createElement('h2');
                header.className = 'custom-formula-view-header';
                header.textContent = 'Uncompleted Sessions';
                headerCard.appendChild(header);

                fragment.appendChild(headerCard);

                const uncompletedCategories = Object.keys(uncompletedSessions);
                if (uncompletedCategories.length === 0) {
                    const emptyCard = document.createElement('div');
                    emptyCard.className = 'custom-formula-card';
                    const p = document.createElement('p');
                    p.className = 'text-center';
                    p.textContent = 'No uncompleted sessions found.';
                    emptyCard.appendChild(p);
                    fragment.appendChild(emptyCard);
                } else {
                    uncompletedCategories.forEach(category => {
                        const subcategories = uncompletedSessions[category];
                        const categoryCard = document.createElement('div');
                        categoryCard.className = 'custom-formula-card';

                        const categoryHeader = document.createElement('div');
                        categoryHeader.className = 'custom-formula-category-header';

                        const h3 = document.createElement('h3');
                        h3.textContent = category;
                        categoryHeader.appendChild(h3);

                        const deleteCategoryBtn = document.createElement('button');
                        deleteCategoryBtn.dataset.action = 'delete-view-category';
                        deleteCategoryBtn.dataset.viewType = 'uncompleted';
                        deleteCategoryBtn.dataset.category = category;
                        deleteCategoryBtn.className = 'custom-formula-btn custom-formula-btn-secondary';
                        deleteCategoryBtn.textContent = 'Delete Category';
                        categoryHeader.appendChild(deleteCategoryBtn);

                        categoryCard.appendChild(categoryHeader);

                        Object.keys(subcategories).forEach(subcategory => {
                            const sessionData = subcategories[subcategory];
                            const items = sessionData.formulas || [];

                            const details = document.createElement('details');
                            details.className = 'custom-formula-subcategory-item';

                            const summary = document.createElement('summary');
                            summary.appendChild(document.createTextNode(subcategory));

                            const viewActions = document.createElement('div');
                            viewActions.className = 'custom-formula-view-actions';

                            const runBtn = document.createElement('button');
                            runBtn.dataset.action = 'run-uncompleted';
                            runBtn.dataset.category = category;
                            runBtn.dataset.subcategory = subcategory;
                            runBtn.className = 'custom-formula-btn custom-formula-btn-small';
                            runBtn.textContent = 'Run';
                            viewActions.appendChild(runBtn);

                            const deleteBtn = document.createElement('button');
                            deleteBtn.dataset.action = 'delete-uncompleted';
                            deleteBtn.dataset.category = category;
                            deleteBtn.dataset.subcategory = subcategory;
                            deleteBtn.className = 'custom-formula-btn custom-formula-btn-secondary custom-formula-btn-small';
                            deleteBtn.textContent = 'Delete';
                            viewActions.appendChild(deleteBtn);

                            summary.appendChild(viewActions);
                            details.appendChild(summary);

                            const ul = document.createElement('ul');
                            items.forEach(item => {
                                const li = document.createElement('li');
                                li.className = 'custom-formula-formula-item with-border';

                                const span = document.createElement('span');
                                span.className = 'custom-formula-formula-text';
                                renderTextWithMath(span, item.text);
                                li.appendChild(span);

                                if (item.subgoals && item.subgoals.length > 0) {
                                    const subUl = document.createElement('ul');
                                    subUl.className = 'custom-formula-subgoal-list';
                                    item.subgoals.forEach(subgoal => {
                                        const subLi = document.createElement('li');
                                        subLi.className = 'custom-formula-formula-item custom-formula-subgoal-item';

                                        const subSpan = document.createElement('span');
                                        subSpan.className = 'custom-formula-formula-text';
                                        renderTextWithMath(subSpan, subgoal.text);
                                        subLi.appendChild(subSpan);
                                        subUl.appendChild(subLi);
                                    });
                                    li.appendChild(subUl);
                                }
                                ul.appendChild(li);
                            });
                            details.appendChild(ul);
                            categoryCard.appendChild(details);
                        });
                        fragment.appendChild(categoryCard);
                    });
                }
                uncompletedDataView.appendChild(fragment);
                showView('uncompleted');
                ensureMathJax().then(() => MathJax.typesetPromise([uncompletedDataView]));
            }

            function showView(viewId) {
                const views = {
                    'main': mainContainer,
                    'saved': savedDataView,
                    'failed': failedDataView,
                    'uncompleted': uncompletedDataView
                };
                for (const id in views) {
                    views[id].style.display = (id === viewId) ? 'block' : 'none';
                }
                document.body.classList.remove('custom-formula-sidebar-open');
                sandwichBtn.setAttribute('aria-expanded', 'false');
            }

            function hideAllViews() {
                showView('main');
                savedDataView.innerHTML = '';
                failedDataView.innerHTML = '';
                uncompletedDataView.innerHTML = '';
            }

            savedDataView.addEventListener('click', async (e) => {
                const target = e.target.closest('button');
                if (!target) return;

                const action = target.dataset.action;
                if (!action) return;

                const { category, subcategory } = target.dataset;

                if (action === 'back-to-main') {
                    hideAllViews();
                } else if (action === 'delete-category') {
                    await deleteSavedCategory(category);
                } else if (action === 'delete-subcategory') {
                    e.preventDefault();
                    await deleteSavedSubcategory(category, subcategory);
                } else if (action === 'edit-subcategory') {
                    e.preventDefault();
                    await editSavedSubcategory(category, subcategory);
                } else if (action === 'ask-ai') {
                    e.preventDefault();
                    exportContext = { category, subcategory };
                    exportModal.classList.add('custom-formula-show');
                }
            });

            cancelExportBtn.addEventListener('click', () => {
                exportModal.classList.remove('custom-formula-show');
            });

            async function getSessionItems(category, subcategory) {
                const savedData = await idbHelper.get('savedFormulaData') || {};
                return savedData[category]?.[subcategory] || [];
            }

            // --- Export Logic ---

            exportTextBtn.addEventListener('click', async () => {
                exportModal.classList.remove('custom-formula-show');
                const { category, subcategory } = exportContext;
                if (!category || !subcategory) return;

                const items = await getSessionItems(category, subcategory);
                if (items.length === 0) {
                    showNotification('Notice', 'No goals to share in this session.');
                    return;
                }

                let shareText = `please explain this session from ${subcategory}\n\n`;
                items.forEach(item => {
                    shareText += `${item.text}\n`;
                    if (item.subgoals && item.subgoals.length > 0) {
                        item.subgoals.forEach(sub => {
                            shareText += ` - ${sub.text}\n`;
                        });
                    }
                    shareText += '\n';
                });

                if (navigator.share) {
                    try {
                        await navigator.share({
                            text: shareText
                        });
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.error('Error sharing:', err);
                            showNotification('Share Error', 'Could not share the content.');
                        }
                    }
                } else {
                    showNotification('Not Supported', 'Native sharing is not supported on this device.');
                    console.log("Share text generated:", shareText);
                }
            });

            async function renderSessionForExport(category, subcategory) {
                const items = await getSessionItems(category, subcategory);
                if (items.length === 0) return null;

                // Create a container for export
                const container = document.createElement('div');
                container.className = 'custom-formula-export-container';

                // Apply styles for consistent rendering
                Object.assign(container.style, {
                    width: '800px',
                    backgroundColor: '#ffffff',
                    padding: '40px',
                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
                    color: '#333333',
                    lineHeight: '1.5',
                    position: 'absolute',
                    left: '-9999px',
                    top: '0'
                });

                // Header
                const header = document.createElement('div');
                header.style.textAlign = 'center';
                header.style.marginBottom = '30px';
                header.style.borderBottom = '2px solid #4a90e2';
                header.style.paddingBottom = '20px';

                const h1 = document.createElement('h1');
                h1.textContent = category;
                h1.style.color = '#4a90e2';
                h1.style.margin = '0 0 10px 0';
                h1.style.fontSize = '28px';
                header.appendChild(h1);

                const h2 = document.createElement('h2');
                h2.textContent = subcategory;
                h2.style.color = '#666666';
                h2.style.margin = '0';
                h2.style.fontSize = '20px';
                h2.style.fontWeight = 'normal';
                header.appendChild(h2);

                container.appendChild(header);

                // Goals list
                const goalsContainer = document.createElement('div');

                items.forEach((item, index) => {
                    const goalItem = document.createElement('div');
                    goalItem.style.marginBottom = '25px';
                    goalItem.style.padding = '15px';
                    goalItem.style.border = '1px solid #e0e0e0';
                    goalItem.style.borderRadius = '8px';
                    goalItem.style.backgroundColor = '#f9f9f9';

                    // Main goal
                    const goalHeader = document.createElement('div');
                    goalHeader.style.display = 'flex';
                    goalHeader.style.alignItems = 'flex-start';
                    goalHeader.style.marginBottom = item.subgoals?.length ? '10px' : '0';

                    const goalNumber = document.createElement('div');
                    goalNumber.textContent = `${index + 1}.`;
                    goalNumber.style.fontWeight = 'bold';
                    goalNumber.style.marginRight = '10px';
                    goalNumber.style.minWidth = '25px';
                    goalNumber.style.color = '#4a90e2';

                    const goalContent = document.createElement('div');
                    goalContent.style.flex = '1';
                    goalContent.className = 'export-goal-content';

                    // Use the same rendering function to ensure MathJax works
                    renderTextWithMath(goalContent, item.text);

                    goalHeader.appendChild(goalNumber);
                    goalHeader.appendChild(goalContent);
                    goalItem.appendChild(goalHeader);

                    // Subgoals
                    if (item.subgoals && item.subgoals.length > 0) {
                        const subgoalsContainer = document.createElement('div');
                        subgoalsContainer.style.marginLeft = '20px';
                        subgoalsContainer.style.paddingLeft = '15px';
                        subgoalsContainer.style.borderLeft = '2px solid #ddd';

                        item.subgoals.forEach((subgoal, subIndex) => {
                            const subgoalItem = document.createElement('div');
                            subgoalItem.style.marginBottom = '8px';
                            subgoalItem.style.padding = '8px';
                            subgoalItem.style.backgroundColor = '#ffffff';
                            subgoalItem.style.borderRadius = '4px';

                            const subgoalContent = document.createElement('div');
                            subgoalContent.className = 'export-subgoal-content';
                            renderTextWithMath(subgoalContent, `â€¢ ${subgoal.text}`);

                            subgoalItem.appendChild(subgoalContent);
                            subgoalsContainer.appendChild(subgoalItem);
                        });

                        goalItem.appendChild(subgoalsContainer);
                    }

                    goalsContainer.appendChild(goalItem);
                });

                container.appendChild(goalsContainer);

                // Add timestamp
                const timestamp = document.createElement('div');
                timestamp.style.textAlign = 'center';
                timestamp.style.marginTop = '30px';
                timestamp.style.paddingTop = '20px';
                timestamp.style.borderTop = '1px solid #e0e0e0';
                timestamp.style.color = '#999999';
                timestamp.style.fontSize = '12px';
                timestamp.textContent = `Generated on ${new Date().toLocaleString()}`;
                container.appendChild(timestamp);

                // Add to DOM for rendering
                document.body.appendChild(container);

                // Wait for MathJax to render completely
                await ensureMathJax();

                // Typeset the container specifically
                try {
                    await MathJax.typesetPromise([container]);

                    // Additional delay to ensure rendering is complete
                    await new Promise(resolve => setTimeout(resolve, 500));
                } catch (error) {
                    console.error('MathJax typesetting error:', error);
                }

                return container;
            }

            exportImageBtn.addEventListener('click', async () => {
                exportModal.classList.remove('custom-formula-show');
                const { category, subcategory } = exportContext;
                if (!category || !subcategory) return;

                showLoading('Generating image... This may take a few seconds.');

                // Yield to UI thread to let the spinner render
                await new Promise(resolve => setTimeout(resolve, 100));

                try {
                    const container = await renderSessionForExport(category, subcategory);
                    if (!container) {
                        hideLoading();
                        showNotification('Error', 'No data to export.');
                        return;
                    }

                    // Ensure container is visible for rendering
                    container.style.display = 'block';
                    container.style.position = 'fixed';
                    container.style.left = '0';
                    container.style.top = '0';
                    container.style.zIndex = '10000';

                    // Use higher quality settings
                    const dataUrl = await htmlToImage.toPng(container, {
                        quality: 1,
                        pixelRatio: 4, // Increased resolution
                        backgroundColor: '#ffffff',
                        width: container.scrollWidth,
                        height: container.scrollHeight,
                        style: {
                            transform: 'none',
                            margin: '0',
                            padding: '40px'
                        }
                    });

                    // Download the image
                    const link = document.createElement('a');
                    link.download = `${category}-${subcategory}-${new Date().getTime()}.png`;
                    link.href = dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    // Cleanup
                    document.body.removeChild(container);
                    hideLoading();

                } catch (err) {
                    console.error('Image export failed:', err);
                    hideLoading();
                    showNotification('Error', 'Failed to generate image. Please try again.');
                    // Clean up if container exists
                    const container = document.querySelector('.custom-formula-export-container');
                    if (container) document.body.removeChild(container);
                }
            });

            exportPdfBtn.addEventListener('click', async () => {
                exportModal.classList.remove('custom-formula-show');
                const { category, subcategory } = exportContext;
                if (!category || !subcategory) return;

                showLoading('Generating PDF... This may take a few seconds.');

                // Yield to UI thread
                await new Promise(resolve => setTimeout(resolve, 100));

                try {
                    const container = await renderSessionForExport(category, subcategory);
                    if (!container) {
                        hideLoading();
                        showNotification('Error', 'No data to export.');
                        return;
                    }

                    // Ensure container is visible for rendering
                    container.style.display = 'block';
                    container.style.position = 'fixed';
                    container.style.left = '0';
                    container.style.top = '0';
                    container.style.zIndex = '10000';

                    // Convert to image first
                    const imgData = await htmlToImage.toPng(container, {
                        quality: 1,
                        pixelRatio: 3, // Balance between quality and size for PDF
                        backgroundColor: '#ffffff',
                        width: container.scrollWidth,
                        height: container.scrollHeight,
                        style: {
                            transform: 'none',
                            margin: '0',
                            padding: '40px'
                        }
                    });

                    // Create PDF
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF({
                        orientation: container.scrollWidth > container.scrollHeight ? 'l' : 'p',
                        unit: 'pt',
                        format: [container.scrollWidth, container.scrollHeight] // Custom size matching the content
                    });

                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();

                    pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
                    pdf.save(`${category}-${subcategory}.pdf`);

                    // Cleanup
                    document.body.removeChild(container);
                    hideLoading();

                } catch (err) {
                    console.error('PDF export failed:', err);
                    hideLoading();
                    showNotification('Error', 'Failed to generate PDF. Please try again.');
                    const container = document.querySelector('.custom-formula-export-container');
                    if (container) document.body.removeChild(container);
                }
            });

            failedDataView.addEventListener('click', async (e) => {
                const target = e.target.closest('button');
                if (!target) return;

                const action = target.dataset.action;
                if (!action) return;

                const { category, subcategory } = target.dataset;

                if (action === 'back-to-main') {
                    hideAllViews();
                } else if (action === 'run-failed') {
                    await runFailedSession(category, subcategory);
                } else if (action === 'delete-failed') {
                    await deleteFailedSession(category, subcategory);
                } else if (action === 'delete-view-category') {
                    const confirmed = await showConfirmation('Delete Category', `Are you sure you want to delete the entire category "${category}" from your failed sessions? This action cannot be undone.`);
                    if (confirmed) {
                        const savedData = await idbHelper.get('savedFormulaData') || {};
                        if (savedData["Failed Sessions"]?.[category]) {
                            delete savedData["Failed Sessions"][category];
                            await saveAllFormulaData(savedData);
                            await showFailedDataView();
                        }
                    }
                }
            });

            uncompletedDataView.addEventListener('click', async (e) => {
                const target = e.target.closest('button');
                if (!target) return;

                const action = target.dataset.action;
                if (!action) return;

                const { category, subcategory } = target.dataset;

                if (action === 'back-to-main') {
                    hideAllViews();
                } else if (action === 'run-uncompleted') {
                    await runUncompletedSession(category, subcategory);
                } else if (action === 'delete-uncompleted') {
                    await deleteUncompletedSession(category, subcategory);
                } else if (action === 'delete-view-category') {
                    const confirmed = await showConfirmation('Delete Category', `Are you sure you want to delete the entire category "${category}" from your uncompleted sessions? This action cannot be undone.`);
                    if (confirmed) {
                        const savedData = await idbHelper.get('savedFormulaData') || {};
                        if (savedData["Uncompleted Sessions"]?.[category]) {
                            delete savedData["Uncompleted Sessions"][category];
                            await saveAllFormulaData(savedData);
                            await showUncompletedDataView();
                        }
                    }
                }
            });

            addFormulaBtn.addEventListener('click', () => {
                const inputText = manualFormulaInput.value.trim();
                if (!inputText) {
                    showNotification('Input Required', 'Please enter one or more goals separated by an emoji.');
                    return;
                }

                const goalStrings = inputText.split(/\p{Emoji_Presentation}/u).map(s => s.trim()).filter(s => s.length > 0);

                if (goalStrings.length === 0) {
                    showNotification('Input Required', 'Please enter one or more valid goals.');
                    return;
                }

                const newFormulas = goalStrings.map(text => createGoal(text));

                if (sessionCategory && sessionSubcategory) {
                    // Session active: add directly, filtering for duplicates
                    const existingFormulas = new Set(formulas.map(f => f.text));
                    const uniqueNewFormulas = newFormulas.filter(f => !existingFormulas.has(f.text));

                    if(uniqueNewFormulas.length === 0) {
                        showNotification('Notice', "The goal(s) you entered already exist in the current session.");
                        return;
                    }

                    formulas.push(...uniqueNewFormulas);
                    saveFormulasToLocalStorage();
                    renderFormulas();
                    manualFormulaInput.value = ''; // Clear input on success
                } else {
                    // No session: use the save modal flow
                    // This assumes the main `formulas` array is empty, which it should be if no session is active.
                    parsedFormulas = newFormulas;
                    saveModal.classList.add('custom-formula-show');
                }
            });

            clearBtn.addEventListener('click', () => {
                if (formulas.length === 0) {
                    showNotification('Notice', 'There are no formulas to clear.');
                    return;
                }
                clearModal.classList.add('custom-formula-show');
                populateClearModalAsync();
            });

            async function populateClearModalAsync() {
                clearFormulaList.innerHTML = '<li>Loading...</li>';
                await new Promise(resolve => setTimeout(resolve, 50)); // Give browser time to render

                clearFormulaList.innerHTML = '';
                if (formulas.length === 0) {
                    clearFormulaList.innerHTML = '<li>No formulas to clear.</li>';
                    return;
                }

                formulas.forEach((formula, index) => {
                    const li = document.createElement('li');
                    li.className = 'custom-formula-formula-item';

                    if (formula.subgoals && formula.subgoals.length > 0) {
                        li.classList.add('with-border');
                    }

                    const goalContent = document.createElement('div');
                    goalContent.className = 'custom-formula-goal-content';
                    goalContent.style.width = '100%';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `custom-formula-clear-formula-${formula.id}`;
                    checkbox.dataset.id = formula.id;

                    const label = document.createElement('label');
                    label.htmlFor = `custom-formula-clear-formula-${formula.id}`;
                    label.className = 'custom-formula-formula-text';
                    renderTextWithMath(label, formula.text);

                    label.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        checkbox.click();
                    });

                    goalContent.appendChild(checkbox);
                    goalContent.appendChild(label);
                    li.appendChild(goalContent);

                    if (formula.subgoals && formula.subgoals.length > 0) {
                        const subgoalsContainer = document.createElement('ul');
                        subgoalsContainer.className = 'custom-formula-subgoal-list';
                        formula.subgoals.forEach(subgoal => {
                            const subLi = document.createElement('li');
                            subLi.className = 'custom-formula-formula-item custom-formula-subgoal-item';

                            const subCheckbox = document.createElement('input');
                            subCheckbox.type = 'checkbox';
                            subCheckbox.id = `custom-formula-clear-formula-${subgoal.id}`;
                            subCheckbox.dataset.id = subgoal.id;
                            subCheckbox.dataset.parentId = formula.id;

                            const subLabel = document.createElement('label');
                            subLabel.htmlFor = `custom-formula-clear-formula-${subgoal.id}`;
                            subLabel.className = 'custom-formula-formula-text';
                            renderTextWithMath(subLabel, subgoal.text);

                            subLabel.addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                subCheckbox.click();
                            });

                            subLi.appendChild(subCheckbox);
                            subLi.appendChild(subLabel);
                            subgoalsContainer.appendChild(subLi);
                        });
                        li.appendChild(subgoalsContainer);
                    }

                    clearFormulaList.appendChild(li);
                });
                await ensureMathJax();
                await MathJax.typesetPromise();
            }

            cancelClearBtn.addEventListener('click', () => {
                clearModal.classList.remove('custom-formula-show');
            });

            clearAllBtn.addEventListener('click', async () => {
                const confirmed = await showConfirmation('Clear All Formulas', 'Are you sure you want to clear all formulas from the current session? This will not affect your saved data.');
                if (confirmed) {
                    formulas = [];
                    sessionCategory = '';
                    sessionSubcategory = '';
                    isEditing = false; // Reset editing flag
                    // Note: saveFormulasToLocalStorage() is intentionally not called here
                    // to avoid overwriting the last saved session with an empty one.
                    renderFormulas();
                    renderSessionHeader(); // This will hide the header
                    clearModal.classList.remove('custom-formula-show');
                }
            });

            clearSelectedBtn.addEventListener('click', () => {
                const checkboxes = clearFormulaList.querySelectorAll('input[type="checkbox"]:checked');
                if (checkboxes.length === 0) {
                    showNotification('Notice', 'No formulas selected to clear.');
                    return;
                }

                const idsToClear = new Set(Array.from(checkboxes).map(cb => cb.dataset.id));

                formulas = formulas.filter(f => !idsToClear.has(f.id));
                formulas.forEach(f => {
                    if (f.subgoals) {
                        f.subgoals = f.subgoals.filter(sg => !idsToClear.has(sg.id));
                    }
                });

                if (formulas.length === 0) {
                    sessionCategory = '';
                    sessionSubcategory = '';
                    isEditing = false;
                }

                saveFormulasToLocalStorage();
                renderFormulas();
                renderSessionHeader(); // This will update/hide the header
                clearModal.classList.remove('custom-formula-show');
            });

            // --- Dark Mode ---
            function setDarkMode(isDark) {
                if (isDark) {
                    document.body.classList.add('custom-formula-dark-mode');
                    saveToLocalStorage('custom-formula-darkMode', 'enabled');
                } else {
                    document.body.classList.remove('custom-formula-dark-mode');
                    saveToLocalStorage('custom-formula-darkMode', 'disabled');
                }
            }

            darkModeSwitch.addEventListener('change', (e) => {
                setDarkMode(e.target.checked);
            });

            function openSubgoalModal(goalId) {
                currentGoalId = goalId;
                subgoalInput.value = '';
                addSubgoalModal.classList.add('custom-formula-show');
                subgoalInput.focus();
            }

            saveSubgoalBtn.addEventListener('click', () => {
                const subgoalText = subgoalInput.value.trim();
                if (!subgoalText) {
                    showNotification('Input Required', 'Please enter a subgoal.');
                    return;
                }

                const parentFormula = formulas.find(f => f.id === currentGoalId);
                if (parentFormula) {
                    const newSubgoal = createSubgoal(subgoalText);
                    parentFormula.subgoals.push(newSubgoal);
                    saveFormulasToLocalStorage();
                    renderFormulas();
                }

                addSubgoalModal.classList.remove('custom-formula-show');
                subgoalInput.value = '';
                currentGoalId = null;
            });

            cancelSubgoalBtn.addEventListener('click', () => {
                addSubgoalModal.classList.remove('custom-formula-show');
                subgoalInput.value = '';
                currentGoalId = null;
            });


            // --- Helpers ---
            function capitalizeFirstLetter(string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
            }

            function renderTextWithMath(parentElement, text) {
                // Securely renders text and MathJax formulas by creating DOM nodes
                parentElement.textContent = ''; // Clear previous content

                const processedText = formatGoalTextForDisplay(text);
                const regex = /(\$\$[\s\S]*?\$\$|\\\[[\s\S]*?\\\])/g;
                const parts = processedText.split(regex);

                const fragment = document.createDocumentFragment();

                for (const part of parts) {
                    if (!part) continue;

                    if (part.startsWith('$$') && part.endsWith('$$')) {
                        const div = document.createElement('div');
                        div.className = 'math-center';
                        div.textContent = part;
                        fragment.appendChild(div);
                    } else if (part.startsWith('\\[') && part.endsWith('\\]')) {
                        const div = document.createElement('div');
                        div.className = 'math-left';
                        div.textContent = part;
                        fragment.appendChild(div);
                    } else {
                        // This handles both plain text and inline math ($...$)
                        // Split by actual newline characters to support explicit line breaks
                        const textParts = part.split(/\r?\n/);
                        textParts.forEach((textPart, index) => {
                            fragment.appendChild(document.createTextNode(textPart));
                            if (index < textParts.length - 1) {
                                fragment.appendChild(document.createElement('br'));
                            }
                        });
                    }
                }
                parentElement.appendChild(fragment);
            }

            function isLikelyMath(text) {
              // It's definitely math if it contains these characters.
              if (/[\\^{}_]/.test(text)) return true;

              // If it has an equals sign, it's probably math, unless it's a long sentence.
              if (text.includes('=') && text.trim().split(/\s+/).length < 4) return true;

              // If it has no spaces and contains letters, it's probably a formula like 'x' or 'abc'.
              if (!text.includes(' ') && /[a-zA-Z]/.test(text)) return true;

              return false;
            }

            function formatGoalTextForDisplay(text) {
                // This function now only ensures the text has the correct delimiters.
                // The actual rendering is handled by renderTextWithMath.
                if (text.includes('$') || text.includes('\\[')) {
                    return text; // Trust user's delimiters
                }
                if (isLikelyMath(text)) {
                    return `$$${text}$$`; // Default likely math to centered display math
                }
                return text; // Treat as plain text
            }

            // --- Data Migration ---
            async function migrateDataFromLocalStorage() {
              const ls = getSafeLocalStorage();
              if (!ls) return; // localStorage unavailable â€” skip migration safely

              const oldDataKey = 'custom-formula-savedFormulaData';
              const oldData = ls.getItem(oldDataKey);

              if (oldData) {
                console.log('Old data found in localStorage. Migrating to IndexedDB...');
                try {
                  const parsedData = JSON.parse(oldData);
                  await idbHelper.set('savedFormulaData', parsedData);
                  ls.removeItem(oldDataKey);
                  console.log('Migration successful. Old data removed from localStorage.');
                  showNotification('Update Complete', 'Your saved data has been moved to a new, more reliable storage system.');
                } catch (error) {
                  console.error('Failed to migrate data:', error);
                  showNotification('Update Error', 'There was an issue updating the application\'s data storage. Your old data has been kept safe.');
                }
              }
            }

            // --- Initial Load ---

            async function handleFailedSession() {
                if (!sessionCategory || !sessionSubcategory || formulas.length === 0) {
                    resetTimer();
                    return;
                }

                const savedData = await idbHelper.get('savedFormulaData') || {};
                let changesMade = false;

                const completedFormulas = formulas.filter(f => f.completed);
                const uncompletedFormulas = formulas.filter(f => !f.completed);

                // 1. Handle completed formulas: Merge them back into the main data store.
                if (completedFormulas.length > 0) {
                    if (!savedData[sessionCategory]) {
                        savedData[sessionCategory] = {};
                    }
                    if (!savedData[sessionCategory][sessionSubcategory]) {
                        savedData[sessionCategory][sessionSubcategory] = [];
                    }

                    completedFormulas.forEach(formula => {
                        const existingFormula = savedData[sessionCategory][sessionSubcategory].find(f => f.text === formula.text);
                        if (existingFormula) {
                            existingFormula.completed = true;
                        } else {
                            savedData[sessionCategory][sessionSubcategory].push(JSON.parse(JSON.stringify(formula)));
                        }
                    });
                    changesMade = true;
                }

                // 2. Handle uncompleted formulas: Save them to a separate "Failed Sessions" object.
                if (uncompletedFormulas.length > 0) {
                    if (!savedData["Failed Sessions"]) savedData["Failed Sessions"] = {};
                    if (!savedData["Failed Sessions"][sessionCategory]) savedData["Failed Sessions"][sessionCategory] = {};
                    if (!savedData["Failed Sessions"][sessionCategory][sessionSubcategory]) {
                        savedData["Failed Sessions"][sessionCategory][sessionSubcategory] = { formulas: [], duration: timerState.duration };
                    } else {
                        // Update duration in case it's a different session length for the same category
                        savedData["Failed Sessions"][sessionCategory][sessionSubcategory].duration = timerState.duration;
                    }

                    const existingFailed = savedData["Failed Sessions"][sessionCategory][sessionSubcategory].formulas;
                    const existingTexts = new Set(existingFailed.map(f => f.text));
                    let addedCount = 0;

                    uncompletedFormulas.forEach(formula => {
                        if (!existingTexts.has(formula.text)) {
                            existingFailed.push(JSON.parse(JSON.stringify(formula)));
                            addedCount++;
                        }
                    });

                    if (addedCount > 0) {
                        changesMade = true;
                        showNotification("Timer Finished", `Your ${addedCount} uncompleted goal(s) for '${sessionSubcategory}' have been moved to 'Failed Sessions'.`);
                    } else {
                        showNotification("Timer Finished", "All goals were completed, and no new uncompleted goals were added to 'Failed Sessions'.");
                    }
                } else {
                    showNotification("Timer Finished", "All goals were completed. Great work!");
                }

                // 3. Persist all changes to IndexedDB.
                if (changesMade) {
                    await saveAllFormulaData(savedData);
                }

                // 4. Clear the main session view and persist the cleared state.
                formulas = [];
                sessionCategory = '';
                sessionSubcategory = '';
                saveFormulasToLocalStorage();

                renderFormulas();
                await renderSavedCategories();

                // The timer is already stopped by the timeout, just need to update UI
                resetTimer();
            }

            function checkActiveTimer() {
                const loadedState = loadTimerState();
                if (loadedState) {
                    // Anti-tampering check: if the last known time is in the future, invalidate it.
                    // Add a 5-second buffer to account for minor, legitimate clock adjustments.
                    if (loadedState.lastUpdated > Date.now() + 5000) {
                        console.warn('[TIMER_LOG] Potential system time tampering detected. Invalidating timer state.');
                        showNotification('Timer Error', 'An inconsistency with the system clock was detected. The timer has been reset.');

                        // Invalidate by resetting to default state
                        resetTimer(); // This function already sets a clean, stopped state
                        return; // Exit to avoid processing the invalid state
                    }

                    console.log('[TIMER_LOG] Found timer state on page load.', loadedState);
                    updateTimerUI(loadedState);
                } else {
                    console.log('[TIMER_LOG] No active timer data found.');
                    updateTimerUI(timerState); // Initialize with default state
                }
            }

            // --- Drag and Drop ---
            const imageUploadLabel = document.querySelector('label[for="custom-formula-image-upload"]');
            const jsonUploadLabel = document.querySelector('label[for="custom-formula-json-upload"]');
            const imageUploadBox = imageUploadLabel.parentElement;
            const jsonUploadBox = jsonUploadLabel.parentElement;
            const imageUploadLabelSpan = imageUploadLabel.querySelector('span');
            const jsonUploadLabelSpan = jsonUploadLabel.querySelector('span');
            const originalImageText = imageUploadLabelSpan.textContent;
            const originalJsonText = jsonUploadLabelSpan.textContent;

            let dragCounter = 0;

            function updateUploadLabel(label, span, newText) {
                if (span.textContent === newText) return;

                label.classList.add('custom-formula-text-fade-out');
                setTimeout(() => {
                    span.textContent = newText;
                    label.classList.remove('custom-formula-text-fade-out');
                }, 150);
            }

            function resetUploadLabels() {
                updateUploadLabel(imageUploadLabel, imageUploadLabelSpan, originalImageText);
                updateUploadLabel(jsonUploadLabel, jsonUploadLabelSpan, originalJsonText);
                imageUploadBox.classList.remove('custom-formula-drag-over', 'custom-formula-drag-invalid');
                jsonUploadBox.classList.remove('custom-formula-drag-over', 'custom-formula-drag-invalid');
            }

            function handleDragEnter(e) {
                e.preventDefault();
                e.stopPropagation();
                dragCounter++;
                if (dragCounter === 1) {
                    document.body.classList.add('custom-formula-drag-active');
                }
            }

            function handleDragLeave(e) {
                e.preventDefault();
                e.stopPropagation();
                dragCounter--;
                if (dragCounter === 0) {
                    document.body.classList.remove('custom-formula-drag-active');
                    resetUploadLabels();
                }
            }

            function handleDragOver(e) {
                e.preventDefault();
                e.stopPropagation();

                const items = e.dataTransfer.items;
                let isImage = false;
                let isJson = false;

                if (items && items.length > 0) {
                    const item = items[0];
                    if (item.kind === 'file') {
                        if (item.type.startsWith('image/')) {
                            isImage = true;
                        } else if (item.type === 'application/json') {
                            isJson = true;
                        }
                    }
                }

                if (isImage) {
                    updateUploadLabel(imageUploadLabel, imageUploadLabelSpan, 'Drop here');
                    imageUploadBox.classList.add('custom-formula-drag-over');
                    imageUploadBox.classList.remove('custom-formula-drag-invalid');

                    updateUploadLabel(jsonUploadLabel, jsonUploadLabelSpan, originalJsonText);
                    jsonUploadBox.classList.remove('custom-formula-drag-over', 'custom-formula-drag-invalid');
                } else if (isJson) {
                    updateUploadLabel(jsonUploadLabel, jsonUploadLabelSpan, 'Drop here');
                    jsonUploadBox.classList.add('custom-formula-drag-over');
                    jsonUploadBox.classList.remove('custom-formula-drag-invalid');

                    updateUploadLabel(imageUploadLabel, imageUploadLabelSpan, originalImageText);
                    imageUploadBox.classList.remove('custom-formula-drag-over', 'custom-formula-drag-invalid');
                } else {
                    updateUploadLabel(imageUploadLabel, imageUploadLabelSpan, 'Not Supported');
                    imageUploadBox.classList.add('custom-formula-drag-invalid');
                    imageUploadBox.classList.remove('custom-formula-drag-over');

                    updateUploadLabel(jsonUploadLabel, jsonUploadLabelSpan, 'Not Supported');
                    jsonUploadBox.classList.add('custom-formula-drag-invalid');
                    jsonUploadBox.classList.remove('custom-formula-drag-over');
                }
            }

            function handleDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                document.body.classList.remove('custom-formula-drag-active');
                resetUploadLabels();
                dragCounter = 0;

                const files = e.dataTransfer.files;
                if (!files || files.length === 0) {
                    return;
                }

                const file = files[0];
                if (file.type.startsWith('image/')) {
                    runOCR(file);
                } else if (file.type === 'application/json') {
                    processJsonFile(file);
                } else {
                    showNotification('Unsupported File', 'Only image and JSON files are supported.');
                }
            }

            document.body.addEventListener('dragenter', handleDragEnter);
            document.body.addEventListener('dragleave', handleDragLeave);
            document.body.addEventListener('dragover', handleDragOver);
            document.body.addEventListener('drop', handleDrop);


            // --- Shortcut Button Logic ---
            function handleShortcutClick(event) {
                const button = event.target.closest('.custom-formula-shortcut-btn');
                if (!button) return;

                const codeToInsert = button.dataset.code;
                let targetInput = null;

                // Determine the active input field by checking which modal is visible
                if (addSubgoalModal.classList.contains('custom-formula-show')) {
                    targetInput = subgoalInput;
                } else {
                    // Fallback to the main goal input if no modal is active
                    targetInput = manualFormulaInput;
                }

                if (targetInput) {
                    targetInput.focus(); // Ensure the input is focused before manipulation
                    const start = targetInput.selectionStart;
                    const end = targetInput.selectionEnd;
                    const text = targetInput.value;
                    const cursorPosition = codeToInsert.indexOf('|');
                    const finalCode = codeToInsert.replace('|', '');

                    // Insert the code and update the value
                    targetInput.value = text.substring(0, start) + finalCode + text.substring(end);

                    // Set the new cursor position
                    if (cursorPosition !== -1) {
                        const newCursorPos = start + cursorPosition;
                        targetInput.setSelectionRange(newCursorPos, newCursorPos);
                    } else {
                        // If no pipe, place cursor at the end of the inserted code
                        const newCursorPos = start + finalCode.length;
                        targetInput.setSelectionRange(newCursorPos, newCursorPos);
                    }
                }
            }

            document.addEventListener('click', handleShortcutClick);


            // --- Initial Load ---

            async function initializeApp() {
                await migrateDataFromLocalStorage();

                // Load dark mode preference
                if (localStorage.getItem('custom-formula-darkMode') === 'enabled') {
                    darkModeSwitch.checked = true;
                    setDarkMode(true);
                }

                // Load formulas from last session
                loadFormulasFromLocalStorage();

                // Render saved categories on load
                await renderSavedCategories();

                // Check for an active timer on load
                checkActiveTimer();
            }

            initializeApp();

        });
    })();
    </script>
</body>
</html>
